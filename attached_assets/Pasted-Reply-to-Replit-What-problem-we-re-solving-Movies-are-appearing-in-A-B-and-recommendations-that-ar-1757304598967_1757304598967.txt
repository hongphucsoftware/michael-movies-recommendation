Reply to Replit

What problem we’re solving

Movies are appearing in A/B and recommendations that are not from our five approved IMDb lists (example: RRR).

This is likely from legacy data sources/caches or a fallback path.

For testing and product consistency, we must hard-lock the catalogue to an allow-list of five IMDb lists only. No fallbacks, no legacy sources.

The five lists (the only allowed sources)

https://www.imdb.com/list/ls094921320/

https://www.imdb.com/list/ls003501243/

https://www.imdb.com/list/ls002065120/

https://www.imdb.com/list/ls000873904/

https://www.imdb.com/list/ls005747458/

(IDs: ls094921320, ls003501243, ls002065120, ls000873904, ls005747458)

Why the hard-lock is necessary

Business rule: the MVP must use only these lists for both A/B pairs and trailer recommendations.

Prevents catalogue contamination from old code paths, caches, or “popular/trending” fallbacks.

Makes results deterministic and debuggable while we iterate on the A/B → trailers logic.

Exact change to implement (no UI/route changes)

Allow-list at build time (catalogue)

During scrape/hydration, stamp every movie with sourceListId (the list it came from).

Only push titles whose sourceListId is in:

ALLOWED = new Set([
  "ls094921320","ls003501243","ls002065120","ls000873904","ls005747458"
])


Do not read from any other data source or environment variable for lists. Ignore/disable any legacy lists, Films101, Google Sheets, “curated” sets, or TMDb trending.

Dedupe + final enforcement

Dedupe by TMDb id.

After dedupe, filter again: catalogue = catalogue.filter(m => ALLOWED.has(m.sourceListId)).

Enforce at every API boundary

Everywhere we create pools for:

GET /api/ab/round

POST /api/score-round

GET /api/catalogue (posters)

GET /api/recs (if used)

Always filter from the allowed catalogue:
pool = catalogue.filter(m => ALLOWED.has(m.sourceListId)).

(Optional but helpful) Audit endpoints

GET /api/audit/summary → counts per sourceListId; must show exactly 5 keys.

GET /api/audit/find?title=RRR → should return empty if a title isn’t in those lists.

Rebuild + run

Kill any running node processes.

Rebuild the catalogue (restart server so the in-memory cache is rebuilt).

Keep all existing response shapes so the UI does not change.

Acceptance criteria

GET /api/audit/summary returns only these keys:
ls094921320, ls003501243, ls002065120, ls000873904, ls005747458.

GET /api/ab/round → every movie returned includes a sourceListId that is in the allow-list.

After POST /api/score-round, all recs also have an allowed sourceListId.

GET /api/audit/find?title=RRR → returns matches: [].

If you prefer the minimal patch instead of the full script:

Add the constant ALLOWED above.

In the build step: only push movies when ALLOWED.has(listId).

Before returning from each endpoint: items = items.filter(m => ALLOWED.has(m.sourceListId)).

Restart so the catalogue rebuilds.