Yep — we can base the whole thing on IMDb’s Top 250 and only use the Top 100 from there. Since you’re on the Node proxy, here’s a clean, drop-in way to do it:

The server scrapes the IMDb Top page (just once per request) and returns the Top 100 IMDb IDs + titles/years.

The client maps each IMDb ID → TMDb movie (via /find), grabs a YouTube trailer, and builds your catalogue.

Your onboarding/test + trailer wheel keep working exactly the same — just with this Top-100 source.

I’ve kept the code tight and resilient to small HTML changes.

1) Patch your server.js

Add these two endpoints (you can paste them near your other routes).
They use the official IMDb Top page and TMDb’s “find by external id”.

// === ADD at top with other imports ===
// (already present) import express from "express";
// (already present) import fetch from "node-fetch";
// (already present) import cors from "cors";
// (already present) import { Readable } from "stream";

// === ADD these two helper functions anywhere in server.js ===
async function fetchText(url) {
  const r = await fetch(url, { redirect: "follow" });
  if (!r.ok) throw new Error(`HTTP ${r.status} ${url}`);
  return r.text();
}

/**
 * Parse IMDb Top page HTML and return [{imdbId, rank, title, year}]
 * We target links like /title/tt1234567/ and read the visible title & year nearby.
 */
function parseImdbTop(html, limit = 100) {
  const out = [];
  const seen = new Set();
  // Fallback-friendly: match title links and capture a window of text to extract name/year
  const re = /\/title\/(tt\d{7,8})\/[^>]*>([^<]+)<\/a>[\s\S]{0,120}?\((\d{4})\)/g;
  let m, rank = 0;
  while ((m = re.exec(html)) && out.length < limit) {
    const imdbId = m[1];
    const title  = m[2].trim();
    const year   = m[3];
    if (seen.has(imdbId)) continue;
    seen.add(imdbId);
    rank += 1;
    out.push({ imdbId, rank, title, year });
  }
  return out;
}

// === ADD these routes below your other /api routes ===

/**
 * GET /api/imdb/top100
 * Scrapes IMDb Top 250 page and returns top 100 basic entries
 * Source: https://www.imdb.com/chart/top/
 */
app.get("/api/imdb/top100", async (req, res) => {
  try {
    const html = await fetchText("https://www.imdb.com/chart/top/");
    const items = parseImdbTop(html, 100);
    if (!items.length) {
      // try the "simple" view as a fallback
      const html2 = await fetchText("https://www.imdb.com/chart/top/?mode=simple");
      const items2 = parseImdbTop(html2, 100);
      return res.json({ items: items2 });
    }
    res.json({ items });
  } catch (e) {
    res.status(502).json({ error: "Failed to fetch IMDb Top 100", detail: String(e) });
  }
});

/**
 * GET /api/tmdb/find/:imdbId
 * Map an IMDb ID to TMDb movie via /find
 */
app.get("/api/tmdb/find/:imdbId", async (req, res) => {
  const { imdbId } = req.params;
  try {
    const url = `${TMDB_API_BASE}/find/${encodeURIComponent(imdbId)}?api_key=${TMDB_KEY}&external_source=imdb_id`;
    const r = await fetch(url, { redirect: "follow" });
    if (!r.ok) return res.status(r.status).send(await r.text());
    const data = await r.json();
    // Prefer movie_results; fall back if ever needed
    const movie = (data.movie_results && data.movie_results[0]) || null;
    res.json({ movie });
  } catch (e) {
    res.status(502).json({ error: "Failed to map IMDb → TMDb", detail: String(e) });
  }
});


Why this is robust: if IMDb tweaks classes/DOM, we’re matching the stable /title/tt…/ pattern and a local window for (YEAR). The endpoint returns {imdbId, rank, title, year} for the Top-100. (Source paths verified: IMDb Top page. 
IMDb
)

2) Patch your client (public/index.html JS)

Replace your buildCatalogue() with this Node-proxy version that uses the new endpoints.
(Leave everything else — onboarding/learning/wheel — exactly as-is.)

// helper to call our server
async function j(url){ const r = await fetch(url); if(!r.ok) throw new Error(r.status); return r.json(); }

// map IMDb -> TMDb movie id using our new endpoint
async function mapImdbToTmdb(imdbId){
  const data = await j(`/api/tmdb/find/${imdbId}`);
  const m = data.movie;
  return m && m.id ? m : null;
}

// prefer YouTube thumbnails for bulletproof posters; you already have videos()
function posterFromYouTube(ytKey){ return `https://i.ytimg.com/vi/${ytKey}/sddefault.jpg`; }

// === REPLACE your buildCatalogue() with this ===
async function buildCatalogue(){
  // 1) get the Top 100 IMDb items from our server
  const { items } = await j("/api/imdb/top100"); // [{ imdbId, rank, title, year }]

  const out = [];
  const seen = new Set();

  // 2) for each IMDb ID, map to TMDb movie, then get a trailer, then build entry
  for (const row of items){
    const { imdbId, title: fallbackName, year: fallbackYear } = row;

    // Map to TMDb
    const tmdbMovie = await mapImdbToTmdb(imdbId).catch(()=>null);
    if (!tmdbMovie) continue;

    const tmdbId = tmdbMovie.id;
    const id = `movie_${tmdbId}`;
    if (seen.has(id)) continue;

    // Find a YouTube Trailer/Teaser
    const vs = await videos("movie", tmdbId).catch(()=>({results:[]}));
    const v  = (vs.results||[]).find(x => x.site==="YouTube" && (x.type==="Trailer" || x.type==="Teaser"));
    if (!v) continue;

    // Poster: use YouTube thumb (rock-solid). If you prefer TMDb posters, swap the line.
    const poster = posterFromYouTube(v.key);
    // const poster = tmdbMovie.poster_path ? `/img/t/p/w500${tmdbMovie.poster_path}` :
    //                tmdbMovie.backdrop_path ? `/img/t/p/w500${tmdbMovie.backdrop_path}` : posterFromYouTube(v.key);

    const name = tmdbMovie.title || fallbackName || "Untitled";
    const year = (tmdbMovie.release_date || fallbackYear || "????").slice(0,4);
    const genre_ids = Array.isArray(tmdbMovie.genre_ids) ? tmdbMovie.genre_ids : []; // some find results include them; if not, it's fine

    const tags = [];
    genre_ids.slice(0,3).forEach(gid => tags.push(genreLabel(gid)));

    out.push({
      id,
      name,
      year,
      poster,
      yt: v.key,
      isSeries: false,
      lenShort: 0,
      tags,
      x: fVec(genre_ids || [], "movie")
    });

    seen.add(id);
    // tiny pacing so we don't hammer APIs
    await new Promise(res => setTimeout(res, 20));
  }

  // Keep IMDb order (no shuffle) — this preserves the Top ranking feel
  return out.slice(0, 100);
}