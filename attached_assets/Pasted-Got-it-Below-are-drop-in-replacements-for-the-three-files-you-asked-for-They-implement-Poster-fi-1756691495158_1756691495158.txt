Got it. Below are drop-in replacements for the three files you asked for. They implement:

Poster-first image logic (with smart fallbacks)

A bigger deduped catalogue (Top Rated + 2020–24 discover) with 6-hour cache and a rebuild endpoint

High-quality trailer picking (official → trailer → YouTube → best resolution)

A 12-dim feature vector per title + MMR diversity for the trailer wheel

1) server/routes.ts
import express, { Request, Response } from "express";

// ---- Config ----
const TMDB_API_KEY = process.env.TMDB_API_KEY || process.env.TMDB_KEY || "";
if (!TMDB_API_KEY) {
  // Don't crash, but make it very obvious in responses.
  console.warn("[TMDB] Missing TMDB_API_KEY (or TMDB_KEY). Set it in Replit Secrets.");
}

const TMDB_BASE = "https://api.themoviedb.org/3";
const IMG_BASE = "https://image.tmdb.org/t/p";
const POSTER_SIZE = "w500";
const BACKDROP_SIZE = "w780";
const CATALOGUE_TTL_MS = 1000 * 60 * 60 * 6; // 6 hours

type TMDbMovie = {
  id: number;
  title?: string;
  name?: string;
  original_title?: string;
  overview?: string;
  genre_ids?: number[];
  release_date?: string;
  poster_path?: string | null;
  backdrop_path?: string | null;
  popularity?: number;
  vote_average?: number;
  vote_count?: number;
};

type CatalogueItem = {
  id: number; // TMDb ID
  title: string;
  overview: string;
  genres: number[];
  releaseDate: string | null;
  popularity: number;
  voteAverage: number;
  voteCount: number;
  posterUrl: string | null;
  backdropUrl: string | null;
};

type TrailerInfo = {
  site: "YouTube" | "Vimeo" | "Unknown";
  key: string;
  url: string;
  name: string;
  size?: number;
  official?: boolean;
  type?: string;
};

const api = express.Router();

// ---- Simple in-memory cache ----
const cache = {
  catalogue: [] as CatalogueItem[],
  ts: 0,
};

function isCatalogueFresh() {
  return Date.now() - cache.ts < CATALOGUE_TTL_MS && cache.catalogue.length > 0;
}

async function tmdb(path: string, params: Record<string, any> = {}) {
  const url = new URL(`${TMDB_BASE}${path}`);
  url.searchParams.set("api_key", TMDB_API_KEY);
  for (const [k, v] of Object.entries(params)) {
    if (v !== undefined && v !== null) url.searchParams.set(k, String(v));
  }
  const res = await fetch(url.toString());
  if (!res.ok) {
    const text = await res.text();
    throw new Error(`TMDb ${path} failed ${res.status}: ${text}`);
  }
  return res.json();
}

function toItem(m: TMDbMovie): CatalogueItem {
  const title =
    m.title || m.name || m.original_title || "(Untitled)";
  const posterUrl = m.poster_path ? `${IMG_BASE}/${POSTER_SIZE}${m.poster_path}` : null;
  const backdropUrl = m.backdrop_path ? `${IMG_BASE}/${BACKDROP_SIZE}${m.backdrop_path}` : null;
  return {
    id: m.id,
    title,
    overview: m.overview ?? "",
    genres: m.genre_ids ?? [],
    releaseDate: m.release_date ?? null,
    popularity: m.popularity ?? 0,
    voteAverage: m.vote_average ?? 0,
    voteCount: m.vote_count ?? 0,
    posterUrl,
    backdropUrl,
  };
}

async function fetchPaged(path: string, params: Record<string, any>, pages: number) {
  const results: TMDbMovie[] = [];
  for (let page = 1; page <= pages; page++) {
    const json = await tmdb(path, { ...params, page });
    const items: TMDbMovie[] = json.results ?? [];
    results.push(...items);
    if (page >= json.total_pages) break;
  }
  return results;
}

/**
 * Build a broad catalogue:
 *  - Top Rated movies (first 10 pages)
 *  - Discover movies from 2020–2024 (first 10 pages over that window)
 * Deduped by TMDb ID.
 */
async function buildCatalogue(): Promise<CatalogueItem[]> {
  if (!TMDB_API_KEY) {
    return [];
  }

  // Top rated gives you a strong core of classics.
  const topRated = await fetchPaged("/movie/top_rated", { language: "en-US" }, 10);

  // Discover: 2020–2024 (recent hits)
  const discoverRecent = await fetchPaged(
    "/discover/movie",
    {
      include_adult: "false",
      include_video: "false",
      language: "en-US",
      sort_by: "popularity.desc",
      "primary_release_date.gte": "2020-01-01",
      "primary_release_date.lte": "2024-12-31",
      with_original_language: "en|ja|ko|hi|fr|es|de|it|pt", // a bit of global spice
    } as any,
    10
  );

  const map = new Map<number, TMDbMovie>();
  for (const m of [...topRated, ...discoverRecent]) {
    if (!m || !m.id) continue;
    if (!map.has(m.id)) map.set(m.id, m);
  }

  const items = Array.from(map.values()).map(toItem);

  // Prefer entries with posters; stable sort to keep "top rated" before "discover"
  items.sort((a, b) => {
    const aHasPoster = a.posterUrl ? 1 : 0;
    const bHasPoster = b.posterUrl ? 1 : 0;
    if (bHasPoster !== aHasPoster) return bHasPoster - aHasPoster;
    // fallback by popularity
    return (b.popularity ?? 0) - (a.popularity ?? 0);
  });

  return items;
}

// ---------- Routes ----------

// Paged catalogue (auto-build on first request / cache expiry)
api.get("/catalogue", async (req: Request, res: Response) => {
  try {
    if (!isCatalogueFresh()) {
      cache.catalogue = await buildCatalogue();
      cache.ts = Date.now();
    }

    const page = Math.max(1, parseInt(String(req.query.page ?? "1"), 10));
    const pageSize = Math.min(100, Math.max(1, parseInt(String(req.query.pageSize ?? "60"), 10)));
    const start = (page - 1) * pageSize;
    const slice = cache.catalogue.slice(start, start + pageSize);

    // Poster-first image policy with graceful fallbacks
    const normalized = slice.map((m) => ({
      ...m,
      image: m.posterUrl || m.backdropUrl || null,
      // keep both for clients that want to pick explicitly
    }));

    res.json({
      ok: true,
      total: cache.catalogue.length,
      page,
      pageSize,
      items: normalized,
      learnedDims: 12, // for the "AI Learning: 4/12" UI
      cacheAgeMs: Date.now() - cache.ts,
    });
  } catch (err: any) {
    res.status(500).json({ ok: false, error: err.message ?? String(err) });
  }
});

// Force rebuild (admin)
api.post("/catalogue/build", async (_req: Request, res: Response) => {
  try {
    cache.catalogue = await buildCatalogue();
    cache.ts = Date.now();
    res.json({ ok: true, total: cache.catalogue.length, rebuiltAt: cache.ts });
  } catch (err: any) {
    res.status(500).json({ ok: false, error: err.message ?? String(err) });
  }
});

// Flush cache (admin)
api.post("/cache/flush", (req: Request, res: Response) => {
  cache.catalogue = [];
  cache.ts = 0;
  res.json({ ok: true });
});

// Trailer for a movie
api.get("/trailer", async (req: Request, res: Response) => {
  try {
    const id = Number(req.query.id);
    if (!id) return res.status(400).json({ ok: false, error: "Missing id" });
    if (!TMDB_API_KEY) return res.status(400).json({ ok: false, error: "TMDB_API_KEY not set" });

    const json = await tmdb(`/movie/${id}/videos`, {
      language: "en-US",
      include_video_language: "en,null",
    });

    type TMDbVideo = {
      site: string;
      key: string;
      name: string;
      official?: boolean;
      size?: number;
      type?: string;
    };

    const vids: TMDbVideo[] = json.results ?? [];

    // Heuristics: official → type Trailer → site YouTube → biggest size → title contains "Official"
    const scored = vids
      .filter((v) => v && v.site && v.key)
      .map((v) => {
        let score = 0;
        if ((v.type || "").toLowerCase() === "trailer") score += 4;
        if (v.official) score += 3;
        if ((v.site || "").toLowerCase() === "youtube") score += 2;
        if ((v.name || "").toLowerCase().includes("official")) score += 1;
        if (v.size) score += Math.min(3, Math.floor((v.size ?? 0) / 360)); // bump for 720/1080
        return { v, score };
      })
      .sort((a, b) => b.score - a.score);

    const best = scored[0]?.v;
    if (!best) return res.json({ ok: true, trailer: null });

    const t: TrailerInfo = {
      site: (best.site as any) || "Unknown",
      key: best.key,
      url:
        (best.site || "").toLowerCase() === "youtube"
          ? `https://www.youtube.com/watch?v=${best.key}`
          : (best.site || "").toLowerCase() === "vimeo"
          ? `https://vimeo.com/${best.key}`
          : best.key,
      name: best.name,
      size: best.size,
      official: best.official,
      type: best.type,
    };

    res.json({ ok: true, trailer: t });
  } catch (err: any) {
    res.status(500).json({ ok: false, error: err.message ?? String(err) });
  }
});

// Simple health
api.get("/health", (_req, res) => {
  res.json({
    ok: true,
    cacheItems: cache.catalogue.length,
    cacheAgeMs: Date.now() - cache.ts,
  });
});

export default api;

/**
 * ---- How to wire this in your server/index.ts (example) ----
 * import express from "express";
 * import api from "./routes";
 * const app = express();
 * app.use(express.json());
 * app.use("/api", api);
 * app.listen(process.env.PORT || 3000);
 */

2) client/src/lib/videoPick.ts
// Poster-first helpers + MMR diversity picking for the trailer wheel

export type Title = {
  id: number;
  title: string;
  overview: string;
  genres: number[];
  releaseDate: string | null;
  popularity: number;
  voteAverage: number;
  voteCount: number;
  posterUrl: string | null;
  backdropUrl: string | null;
  image?: string | null;
  // computed:
  feature?: number[]; // 12-dim vector
};

const GENRE_BUCKETS = [
  28, // Action
  12, // Adventure
  16, // Animation
  35, // Comedy
  80, // Crime
  18, // Drama
  14, // Fantasy
  27, // Horror
  9648, // Mystery
  878, // Sci-Fi
];

/**
 * Build a 12-dim feature vector:
 *  - 10 dims: genre buckets (binary presence)
 *  - 1 dim: era recency (>=2020 -> 1, else 0)
 *  - 1 dim: normalized popularity (0..1)
 */
export function toFeatureVector(t: Title): number[] {
  const g = new Array<number>(GENRE_BUCKETS.length).fill(0);
  (t.genres || []).forEach((gid) => {
    const idx = GENRE_BUCKETS.indexOf(gid);
    if (idx >= 0) g[idx] = 1;
  });

  const era =
    t.releaseDate && Number((t.releaseDate || "").slice(0, 4)) >= 2020 ? 1 : 0;

  // normalize popularity softly
  const pop = Math.max(0, Math.min(1, t.popularity / 100));

  return [...g, era, pop];
}

/** Cosine similarity for vectors */
function cosine(a: number[], b: number[]): number {
  let dot = 0,
    na = 0,
    nb = 0;
  const len = Math.min(a.length, b.length);
  for (let i = 0; i < len; i++) {
    dot += a[i] * b[i];
    na += a[i] * a[i];
    nb += b[i] * b[i];
  }
  const denom = Math.sqrt(na) * Math.sqrt(nb) || 1;
  return dot / denom;
}

/**
 * MMR selection:
 *  score = λ * sim(item, user) - (1-λ) * max_j sim(item, chosen_j)
 */
export function mmrPick(
  pool: Title[],
  userVec: number[],
  k = 10,
  lambda = 0.7
): Title[] {
  const chosen: Title[] = [];
  const remaining = pool.slice();

  while (chosen.length < k && remaining.length > 0) {
    let best: { item: Title; score: number } | null = null;

    for (const item of remaining) {
      const f = item.feature || toFeatureVector(item);
      const rel = cosine(f, userVec);
      const divPenalty =
        chosen.length === 0
          ? 0
          : Math.max(
              ...chosen.map((c) => cosine(f, c.feature || toFeatureVector(c)))
            );
      const score = lambda * rel - (1 - lambda) * divPenalty;

      if (!best || score > best.score) best = { item, score };
    }

    if (!best) break;

    chosen.push(best.item);
    const idx = remaining.findIndex((t) => t.id === best!.item.id);
    if (idx >= 0) remaining.splice(idx, 1);
  }

  return chosen;
}

/** Poster-first URL */
export function bestImageUrl(t: Title): string | null {
  if (t.posterUrl) return t.posterUrl;
  if (t.backdropUrl) return t.backdropUrl;
  if (t.image) return t.image;
  return null;
}

/** Fetch a trailer URL from the server for a TMDb id */
export async function getTrailerUrl(tmdbId: number): Promise<string | null> {
  const res = await fetch(`/api/trailer?id=${tmdbId}`);
  if (!res.ok) return null;
  const json = await res.json();
  const t = json?.trailer;
  if (!t) return null;
  return t.url || null;
}

/**
 * Build a "wheel" of k diverse trailers given a pool and a learned user vector.
 * Returns titles plus a lazy loader that resolves trailer URLs only when needed.
 */
export function buildTrailerWheel(
  pool: Title[],
  userVec: number[],
  k = 12
): {
  picks: Title[];
  loadTrailer: (idx: number) => Promise<{ url: string | null; id: number }>;
} {
  // ensure features present
  const withF = pool.map((t) => ({ ...t, feature: t.feature || toFeatureVector(t) }));
  const picks = mmrPick(withF, userVec, k);

  async function loadTrailer(idx: number) {
    const t = picks[idx];
    if (!t) return { url: null, id: -1 };
    const url = await getTrailerUrl(t.id);
    return { url, id: t.id };
  }

  return { picks, loadTrailer };
}

3) client/src/hooks/useEnhancedCatalogue.ts
import { useEffect, useMemo, useState } from "react";
import type { Title } from "../lib/videoPick";
import { bestImageUrl, toFeatureVector } from "../lib/videoPick";

type CatalogueResponse = {
  ok: boolean;
  total: number;
  page: number;
  pageSize: number;
  items: Title[];
  learnedDims: number;
  cacheAgeMs: number;
};

export function useEnhancedCatalogue(page = 1, pageSize = 60) {
  const [items, setItems] = useState<Title[]>([]);
  const [total, setTotal] = useState(0);
  const [loading, setLoading] = useState(true);
  const [err, setErr] = useState<string | null>(null);

  useEffect(() => {
    let cancelled = false;
    (async () => {
      try {
        setLoading(true);
        setErr(null);
        const res = await fetch(`/api/catalogue?page=${page}&pageSize=${pageSize}`);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const json: CatalogueResponse = await res.json();
        if (cancelled) return;

        const enriched = (json.items || []).map((t) => {
          const image = bestImageUrl(t);
          const feature = toFeatureVector(t);
          return { ...t, image, feature };
        });

        setItems(enriched);
        setTotal(json.total || enriched.length);
      } catch (e: any) {
        if (!cancelled) setErr(e?.message ?? String(e));
      } finally {
        if (!cancelled) setLoading(false);
      }
    })();
    return () => {
      cancelled = true;
    };
  }, [page, pageSize]);

  return { items, total, loading, error: err };
}

/**
 * Minimal learned vector:
 *  - Start neutral (zeros)
 *  - Each "like" nudges toward that title's feature vector
 *  - Each "skip" nudges away
 * This is intentionally simple and stable.
 */
export function useLearnedVector(dim = 12) {
  const [vec, setVec] = useState<number[]>(() => new Array(dim).fill(0));

  function like(t: Title) {
    const f = t.feature || toFeatureVector(t);
    setVec((old) => old.map((v, i) => clamp(v + 0.15 * f[i], -1, 1)));
  }

  function skip(t: Title) {
    const f = t.feature || toFeatureVector(t);
    setVec((old) => old.map((v, i) => clamp(v - 0.1 * f[i], -1, 1)));
  }

  const learned = useMemo(() => vec.slice(), [vec]);
  return { learned, like, skip };
}

function clamp(n: number, a: number, b: number) {
  return Math.max(a, Math.min(b, n));
}

How to plug this in (quick)

Server wiring

Ensure your Express app uses the router:

// server/index.ts
import express from "express";
import api from "./routes";

const app = express();
app.use(express.json());
app.use("/api", api);

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`Server on :${PORT}`));


Replit Secrets

Add a secret: Key TMDB_API_KEY → Value your TMDb v3 key (from themoviedb.org).

Client

Your existing components can now call:

const { items } = useEnhancedCatalogue();

Use image={bestImageUrl(item)} for posters (no more cropped backdrops).

Build a diverse trailer reel:

import { buildTrailerWheel } from "../lib/videoPick";
const wheel = buildTrailerWheel(items, learnedVector, 12);
// await wheel.loadTrailer(i) to get a playable URL


Admin (optional)

Rebuild catalogue after first boot:

POST /api/catalogue/build

Flush cache if things look stale:

POST /api/cache/flush

If you paste these files in and set TMDB_API_KEY, you should immediately see real posters in the grid and trailers loading when requested. If anything still renders blank, tell me what error you see in the Replit console and I’ll adjust fast.