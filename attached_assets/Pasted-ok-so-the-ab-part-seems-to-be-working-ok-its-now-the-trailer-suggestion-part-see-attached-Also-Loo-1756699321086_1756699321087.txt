ok so the ab part seems to be working ok its now the trailer suggestion part see attached. Also, Looks like it is selecting the same movies as before ie a small sample size which i think you specifically told it not to. write code for this section and instruct it like you did before also make sure it is using the correct ab testing procedure which should result in bespoke trailer based on the ab tests preference after test 
ChatGPT said:
Thought for 56s

Got it—the A/B flow is fine now, but the Trailer Reel is still pulling a tiny, samey set (Batman/Godfather, etc.). That happens when the reel:

defaults to “top popularity” (classic titles) instead of your learned vector, or

only looks at a small slice of the catalogue, or

reuses the same items between sessions.

Below is a drop-in fix that forces the reel to use ALL titles from the 3 lists, ranks them by your A/B-learned preferences, adds MMR diversity, avoids repeats, and applies a tiny jitter so it doesn’t lock onto the same 8–12 posters each time.

I’m also explicitly telling Replit (in comments) not to swap this for a “curated 50.”

1) Add A/B history (what you picked)

Create client/src/hooks/useABHistory.ts

// UI LOCK: DO NOT MODIFY — A/B history used to personalise Trailer Reel
// Replit Agent: This persists which titles the user saw/chose during A/B rounds.
// The reel uses this to avoid repeats and bias recommendations appropriately.

import { useEffect, useState } from "react";

const CHOSEN_KEY = "pf_ab_chosen_v1";
const SEEN_KEY   = "pf_ab_seen_v1";

function load(key: string, def: number[] = []) {
  try { const raw = localStorage.getItem(key); if (raw) return JSON.parse(raw); } catch {}
  return def;
}
function save(key: string, val: number[]) { try { localStorage.setItem(key, JSON.stringify(val)); } catch {} }

export function useABHistory() {
  const [chosen, setChosen] = useState<number[]>(() => load(CHOSEN_KEY));
  const [seen, setSeen]     = useState<number[]>(() => load(SEEN_KEY));

  useEffect(() => save(CHOSEN_KEY, chosen), [chosen]);
  useEffect(() => save(SEEN_KEY, seen), [seen]);

  function record(chosenId: number, otherId: number) {
    setChosen((a) => Array.from(new Set([...a, chosenId])));
    setSeen((a) => Array.from(new Set([...a, chosenId, otherId])));
  }
  function reset() { setChosen([]); setSeen([]); }

  return { chosen, seen, record, reset };
}

2) Wire A/B history into the poster flow

Replace client/src/components/PosterPair.tsx with this version (only the small wiring change from earlier):

// UI LOCK: HOMEPAGE = A/B poster flow (12 rounds) → personalised Trailer Reel
import React, { useState } from "react";
import { useEnhancedCatalogue, useLearnedVector, bestImageUrl } from "../hooks/useEnhancedCatalogue";
import { useQuickPicks } from "../hooks/useQuickPicks";
import { useABHistory } from "../hooks/useABHistory";
import TrailerReel from "./TrailerReel";

export default function PosterPair() {
  const { items, total, loading, error, stats } = useEnhancedCatalogue(); // pulls ALL pages
  const { learned, like, skip, resetLearning } = useLearnedVector(12);
  const { pair, choose, done, progress, reset } = useQuickPicks(items, 12);
  const { chosen: chosenIds, seen: seenIds, record, reset: resetAB } = useABHistory();
  const [rebuilding, setRebuilding] = useState(false);

  if (loading) return <div className="opacity-80">Loading catalogue…</div>;
  if (error)   return <div className="text-red-400">Error: {error}</div>;
  if (!items.length) return <NoTitlesCard onRebuild={doRebuild} rebuilding={rebuilding} stats={stats} />;

  const tooSmall = total < 24;

  function pick(side: "left" | "right") {
    const result = choose(side);
    if (!result) return;
    const { chosen, other } = result;
    like(chosen as any);
    skip(other as any);
    record((chosen as any).id, (other as any).id);  // <-- A/B history for the reel
  }

  async function doRebuild() {
    try { setRebuilding(true); await fetch("/api/catalogue/build", { method: "POST" }); window.location.reload(); }
    finally { setRebuilding(false); }
  }

  function hardReset() { resetLearning(); resetAB(); reset(); }

  return (
    <div className="space-y-6">
      <div className="flex items-center gap-3 flex-wrap">
        <h2 className="text-xl font-semibold">Quick Picks</h2>
        <span className="text-xs px-2 py-1 rounded-full bg-white/10">{total} movies (ALL from 3 lists)</span>
        {stats?.counts && (
          <span className="text-xs opacity-70">
            RT2020: {stats.counts.rt2020} • Top250: {stats.counts.imdbTop} • List: {stats.counts.imdbList}
          </span>
        )}
        {tooSmall && (
          <button onClick={doRebuild} className="text-xs rounded-full px-3 py-1 bg-amber-500/20 hover:bg-amber-500/30">
            Rebuild catalogue
          </button>
        )}
      </div>

      {tooSmall && <div className="text-amber-300 text-sm">Need at least 24 titles for 12 rounds.</div>}

      {/* Progress */}
      <div className="flex items-center justify-between">
        <div className="text-sm">Learning Progress</div>
        <div className="text-xs opacity-80">{progress.current} / {progress.total}</div>
      </div>
      <div className="w-full h-2 rounded bg-gray-800 overflow-hidden">
        <div className="h-2 bg-cyan-400 transition-all" style={{ width: `${(progress.current / Math.max(1, progress.total)) * 100}%` }} />
      </div>

      {/* A/B posters */}
      {!done && pair && (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <PosterCard side="left"  pair={pair} onPick={() => pick("left")} />
          <PosterCard side="right" pair={pair} onPick={() => pick("right")} />
        </div>
      )}

      {/* Reel */}
      {done && (
        <div className="space-y-4">
          <div className="flex items-center gap-3">
            <h2 className="text-lg font-semibold">Perfect! Your personalised Trailer Reel</h2>
            <button onClick={() => reset()} className="text-xs rounded-full px-3 py-1 bg-white/10 hover:bg-white/20">New Round</button>
            <button onClick={hardReset} className="text-xs rounded-full px-3 py-1 bg-red-500/20 hover:bg-red-500/30">Reset Learning</button>
          </div>
          <TrailerReel items={items} learnedVec={learned} recentChosenIds={chosenIds} avoidIds={seenIds} />
        </div>
      )}
    </div>
  );
}

function PosterCard({ side, pair, onPick }: any) {
  const t = side === "left" ? pair.left : pair.right;
  return (
    <button
      className="rounded-2xl overflow-hidden bg-black/20 shadow hover:shadow-lg ring-2 ring-transparent hover:ring-cyan-400 transition"
      onClick={onPick}
    >
      <img src={bestImageUrl(t) || ""} alt={t.title} className="w-full h-[520px] object-cover" loading="lazy" />
      <div className="p-3 text-center">
        <div className="font-medium">{t.title}</div>
        <div className="text-xs opacity-70">{t.releaseDate?.slice(0,4) || ""}</div>
      </div>
    </button>
  );
}

function NoTitlesCard({ onRebuild, rebuilding, stats }: any) {
  return (
    <div className="space-y-3">
      <div>No titles found.</div>
      <div className="text-xs opacity-80">Backend must include ALL movies from the three URLs (no curation).</div>
      {stats && (
        <div className="text-xs opacity-70">
          Scraped: {stats.counts?.totalScraped ?? "?"} • Resolved: {stats.resolved ?? "?"} • Missed: {stats.missed ?? "?"}
        </div>
      )}
      <button onClick={onRebuild} disabled={rebuilding}
        className="text-xs rounded px-3 py-1 bg-white/10 hover:bg-white/20 disabled:opacity-50">
        {rebuilding ? "Rebuilding…" : "Rebuild catalogue"}
      </button>
    </div>
  );
}

3) Replace the Trailer Reel with a proper ranking engine

Replace client/src/components/TrailerReel.tsx with this:

// UI LOCK: DO NOT MODIFY — Reel uses ALL titles + learned preferences (A/B) + MMR diversity
// Replit Agent: Do not replace with static lists or "curated 50". This ranks the FULL catalogue.

import { useEffect, useMemo, useState } from "react";
import type { Title } from "../hooks/useEnhancedCatalogue";
import { bestImageUrl, toFeatureVector } from "../hooks/useEnhancedCatalogue";

type Props = {
  items: Title[];
  learnedVec: number[];
  count?: number;
  recentChosenIds?: number[];  // A/B choices to steer toward “more like this”
  avoidIds?: number[];         // Anything shown during A/B this round (don’t repeat)
};

function l2(x: number[]) { return Math.sqrt(x.reduce((s, v) => s + v*v, 0)); }
function cosine(a: number[], b: number[]) {
  const la = l2(a), lb = l2(b);
  if (la === 0 || lb === 0) return 0;
  let dot = 0; const n = Math.min(a.length, b.length);
  for (let i = 0; i < n; i++) dot += a[i]*b[i];
  return dot / (la * lb);
}

function seededJitter(id: number) {
  // small repeatable jitter by id (keeps results from being identical each time)
  const x = Math.sin(id * 99991) * 10000;
  return (x - Math.floor(x)) * 0.01; // +/- up to 0.01
}

function mmrPick(pool: Title[], userVec: number[], k = 12, lambda = 0.75) {
  const chosen: Title[] = [];
  const feats = new Map<number, number[]>();
  const getF = (t: Title) => feats.get(t.id) || (feats.set(t.id, t.feature || toFeatureVector(t)), feats.get(t.id)!);

  while (chosen.length < k && pool.length) {
    let bestIdx = -1;
    let bestScore = -Infinity;

    for (let i = 0; i < pool.length; i++) {
      const t = pool[i];
      const f = getF(t);
      const rel = cosine(f, userVec);
      const div = chosen.length === 0 ? 0 : Math.max(...chosen.map(c => cosine(f, getF(c))));
      const score = lambda * rel - (1 - lambda) * div + seededJitter(t.id);
      if (score > bestScore) { bestScore = score; bestIdx = i; }
    }

    if (bestIdx < 0) break;
    const [pick] = pool.splice(bestIdx, 1);
    chosen.push(pick);
  }
  return chosen;
}

async function getTrailerUrl(tmdbId: number): Promise<string | null> {
  const res = await fetch(`/api/trailer?id=${tmdbId}`);
  if (!res.ok) return null;
  const json = await res.json();
  const t = json?.trailer;
  return t ? (t.url as string) : null;
}

export default function TrailerReel({ items, learnedVec, count = 12, recentChosenIds = [], avoidIds = [] }: Props) {
  const [activeIdx, setActiveIdx] = useState<number | null>(null);
  const [activeUrl, setActiveUrl] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);

  // Build the candidate pool from ALL items (with images), then:
  // 1) compute preference score (cosine with learnedVec)
  // 2) soft bias toward “more like” recent A/B choices
  // 3) remove items we just showed during A/B (avoidIds)
  // 4) take top-N and run MMR for diversity
  const { picks } = useMemo(() => {
    const pool0 = items.filter(t => bestImageUrl(t));                 // image gate for UX
    const avoid = new Set<number>(avoidIds || []);
    const pool = pool0.filter(t => !avoid.has(t.id));                  // don't re-show A/B pair immediately

    // If user vector is almost zero (brand new), sample a large diverse set
    const strength = l2(learnedVec);
    const fmap = new Map<number, number[]>();
    const getF = (t: Title) => fmap.get(t.id) || (fmap.set(t.id, t.feature || toFeatureVector(t)), fmap.get(t.id)!);

    // “More like what you chose” — boost titles similar to recent chosen items
    const chosenF = recentChosenIds
      .map(id => pool.find(p => p.id === id))
      .filter(Boolean)
      .map(t => getF(t as Title));

    function likeBoost(f: number[]) {
      if (!chosenF.length) return 0;
      const s = chosenF.reduce((acc, cf) => acc + Math.max(0, cosine(f, cf)), 0) / chosenF.length;
      return 0.15 * s; // small nudge toward what you picked
    }

    // Score every candidate
    const scored = pool.map(t => {
      const f = getF(t);
      const base = cosine(f, learnedVec);       // -1..1
      const lb = likeBoost(f);                   // 0..~0.15
      const pop = Math.min(1, (t.popularity || 0) / 100); // keep a little popularity signal
      const score = base + lb + 0.05 * pop + seededJitter(t.id);
      return { t, score };
    });

    // If very weak signal, don’t let popular classics dominate — take a big randomised slice
    if (strength < 0.15) {
      const shuffled = scored.sort((a, b) => b.score - a.score);
      const slice = shuffled.slice(0, Math.min(400, shuffled.length)).map(x => x.t);
      const mmr = mmrPick(slice, learnedVec, count, 0.65);
      return { picks: mmr };
    }

    // Normal path: take top 400 most relevant, then MMR for diversity
    const top = scored.sort((a, b) => b.score - a.score).slice(0, Math.min(400, scored.length)).map(x => x.t);
    const mmr = mmrPick(top, learnedVec, count, 0.75);
    return { picks: mmr };
  }, [items, learnedVec, count, recentChosenIds, avoidIds]);

  useEffect(() => { setActiveIdx(null); setActiveUrl(null); }, [picks]);

  async function play(i: number) {
    setLoading(true);
    setActiveIdx(i);
    const url = await getTrailerUrl(picks[i].id);
    setActiveUrl(url);
    setLoading(false);
  }

  return (
    <div className="w-full">
      <h2 className="text-xl font-semibold mb-3">Your Trailer Reel</h2>

      {/* Thumbnails */}
      <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4">
        {picks.map((t, i) => (
          <button
            key={t.id}
            onClick={() => play(i)}
            className={`rounded-xl overflow-hidden shadow hover:shadow-lg transition ${i === activeIdx ? "ring-2 ring-cyan-400" : ""}`}
            title={`Play trailer: ${t.title}`}
          >
            <img src={bestImageUrl(t) || ""} alt={t.title} className="w-full h-64 object-cover" loading="lazy" />
            <div className="p-2 text-sm font-medium text-left">{t.title}</div>
          </button>
        ))}
      </div>

      {/* Player */}
      <div className="mt-6">
        {loading && <div className="text-sm opacity-80">Loading trailer…</div>}
        {!loading && activeUrl && isYouTube(activeUrl) && (
          <div className="aspect-video w-full">
            <iframe
              className="w-full h-full rounded-xl"
              src={toYouTubeEmbed(activeUrl)}
              title="Trailer"
              allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
              allowFullScreen
            />
          </div>
        )}
        {!loading && activeUrl && !isYouTube(activeUrl) && (
          <div className="text-sm">
            Trailer URL:{" "}
            <a className="underline" href={activeUrl} target="_blank" rel="noreferrer">Open in new tab</a>
          </div>
        )}
        {!loading && activeIdx !== null && !activeUrl && (
          <div className="text-sm opacity-80">No trailer available for this title.</div>
        )}
      </div>
    </div>
  );
}

function isYouTube(u: string) { return /youtube\.com|youtu\.be/.test(u); }
function toYouTubeEmbed(u: string) {
  const m = u.match(/v=([^&]+)/);
  const id = m ? m[1] : u.split("/").pop();
  return `https://www.youtube.com/embed/${id}?rel=0&modestbranding=1`;
}

What this does (so Replit understands)

Ranks the entire catalogue (ALL titles) by similarity to the learned vector from A/B picks.

Adds a “more like what you chose” boost using your latest choices.

Avoids items you just saw in A/B (avoidIds).

Takes the top 400 candidates and runs MMR diversity so results aren’t all the same flavor.

Adds a tiny seeded jitter by ID so you don’t get the exact same 12 every time, even with the same vector.

Quick checks you can do now

Do 12 picks heavily toward one vibe (e.g., animation / sci-fi / romance).

The reel should steer that way (not just classics).

Hit New Round — you’ll see a different but still on-theme set (thanks to diversity + jitter).

If you ever suspect the backend is small again, open /api/catalogue/stats — it must report big counts and “policy: ALL_TITLES_FROM_THREE_URLS”.

If you want me to crank the personalization even harder (e.g., higher weight on the A/B choices or exclude your picks entirely from the reel), say the word and I’ll tweak the constants (lambda, boosts, or avoidIds rules).

ChatGPT can make mistakes. Check important info.