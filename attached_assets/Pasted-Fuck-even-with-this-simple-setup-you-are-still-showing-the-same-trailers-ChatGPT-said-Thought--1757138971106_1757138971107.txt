Fuck!!!!! even with this simple setup you are still showing the same trailers
ChatGPT said:
Thought for 23s

Got it. We’ll make this dead-simple and genre-only, and force the trailer list to change every time you click—no excuses.

Below is a minimal, copy-paste patch for server + client that:

learns only genres from your A/B choice,

ranks recs only by genre score,

rotates the top list per round so you see different trailers even when scores tie,

no cache, and forces React to re-mount iframes so you actually see the new set.

SERVER (routes.ts)
1) Session + no-cache helpers (top of file)
type GenreId = number;
type GenreProfile = { genreScores: Record<GenreId, number>; rounds: number; seenPairs: Set<string> };
const PROFILES = new Map<string, GenreProfile>();

function sess(req: import("express").Request): GenreProfile {
  const sid = (req.headers["x-session-id"] as string) || (req.query.sid as string) || "anon";
  let p = PROFILES.get(sid);
  if (!p) { p = { genreScores: {}, rounds: 0, seenPairs: new Set() }; PROFILES.set(sid, p); }
  return p;
}
function noStore(res: import("express").Response) {
  res.setHeader("Cache-Control", "no-store, no-cache, must-revalidate, max-age=0");
  res.setHeader("Pragma", "no-cache");
  res.setHeader("Vary", "x-session-id");
}


Keep your existing catalogue build that populates CATALOGUE (from your IMDb lists) and AB_SET (your A/B pool). We reuse item.genres from TMDb.

2) Genre-only scorer + rotation per round
function scoreByGenres(genres: number[]|undefined, gp: GenreProfile): number {
  let s = 0; for (const g of genres || []) s += gp.genreScores[g] || 0; return s;
}

// Deterministic light shuffle seeded by round count
function seedSortKey(id: number, rounds: number) {
  return ((id * 1103515245 + 12345 + rounds * 1337) >>> 0) / 2**32;
}

function rankRecsByGenre(gp: GenreProfile, topN: number): Item[] {
  const pool = CATALOGUE.filter(x => !AB_SET.has(x.id)); // rec pool only

  if (gp.rounds === 0) {
    // no signal yet: popularity baseline
    return pool.slice().sort((a,b) =>
      ((b.voteAverage||0)*Math.log(1+(b.voteCount||1))) - ((a.voteAverage||0)*Math.log(1+(a.voteCount||1)))
    ).slice(0, topN);
  }

  // 1) score by genre counts only
  const ranked = pool.map(it => ({
    it,
    s: scoreByGenres(it.genres, gp),
    j: seedSortKey(it.id, gp.rounds), // tie-break
  }))
  .sort((a,b) => (b.s - a.s) || (b.j - a.j))
  .map(x => x.it);

  // 2) visible variety: rotate the window each round
  const window = Math.min(8, Math.max(1, Math.floor(topN/3)));
  const offset = (gp.rounds % 5) * window; // shift by a few slots each round
  const rotated = ranked.slice(offset).concat(ranked.slice(0, offset));

  return rotated.slice(0, topN);
}

3) Vote → learn genres → return fresh recs now

Replace your /api/ab/vote with:

api.post("/api/ab/vote", import("express").json(), async (req, res) => {
  noStore(res);
  const { leftId, rightId, chosenId } = req.body as { leftId:number; rightId:number; chosenId:number };
  const p = sess(req);
  const chosen = CATALOGUE.find(i => i.id === chosenId);
  if (!chosen) return res.status(400).json({ ok:false, error:"bad chosenId" });

  // genre-only learning
  for (const g of (chosen.genres || [])) p.genreScores[g] = (p.genreScores[g] || 0) + 1;
  p.rounds += 1;

  const recItems = rankRecsByGenre(p, 20).map(t => ({
    id: t.id, title: t.title, year: t.year,
    image: t.posterUrl || t.backdropUrl,
    posterUrl: t.posterUrl, backdropUrl: t.backdropUrl, genres: t.genres
  }));

  return res.json({
    ok: true,
    rounds: p.rounds,
    topGenres: Object.entries(p.genreScores).sort((a,b)=>b[1]-a[1]).slice(0,5),
    recs: recItems
  });
});

4) Genre recs endpoint (if you need to fetch later)
api.get("/api/recs-genre", async (req, res) => {
  noStore(res);
  await buildAll();
  const p = sess(req);
  const top = Number(req.query.top || 20);
  const items = rankRecsByGenre(p, top).map(t => ({
    id: t.id, title: t.title, year: t.year,
    image: t.posterUrl || t.backdropUrl,
    posterUrl: t.posterUrl, backdropUrl: t.backdropUrl, genres: t.genres
  }));
  res.json({ ok:true, rounds:p.rounds, items });
});

5) Trailers: also set no-cache
api.get("/api/trailers", async (req, res) => {
  noStore(res);
  // ... your existing trailer batching code
});

CLIENT (React)

Goal: After each vote, show the new recs & trailers, and force React to re-mount the iframes so the carousel visibly changes.

1) Stable session id (once)
// client/src/lib/session.ts
export const getSID = () => {
  const K="paf.sid"; let s = localStorage.getItem(K);
  if (!s) { s = "sid_"+Math.random().toString(36).slice(2)+Date.now().toString(36); localStorage.setItem(K,s); }
  return s;
};

2) Vote → fetch fresh recs → fetch trailers → update state
// in your A/B component
import { getSID } from "../lib/session";
const sid = getSID();

async function submitVote(leftId:number, rightId:number, chosenId:number) {
  const vote = await fetch(`/api/ab/vote?sid=${sid}`, {
    method: "POST",
    headers: { "Content-Type":"application/json", "Cache-Control":"no-store", "x-session-id": sid },
    cache: "no-store",
    body: JSON.stringify({ leftId, rightId, chosenId })
  }).then(r=>r.json());

  if (!vote?.ok) return;

  const ids = vote.recs.map((m:any)=>m.id).join(",");
  const tr = await fetch(`/api/trailers?sid=${sid}&ids=${encodeURIComponent(ids)}&t=${Date.now()}`, {
    headers: { "Cache-Control": "no-store" }, cache: "no-store"
  }).then(r=>r.json());

  const byId = tr?.trailers || {};
  const withTrailers = vote.recs.map((m:any)=>({ ...m, trailer: byId[m.id] ?? null }));

  // IMPORTANT: include vote.rounds in state so React re-mounts iframes
  setRecommendations({ rounds: vote.rounds, items: withTrailers });
}

3) Render trailers (force re-mount on each round)
// in your trailer strip component
export default function TrailerStrip({ model }: { model: { rounds: number; items: any[] } }) {
  const { rounds, items } = model;
  return (
    <div className="trailer-strip">
      {items.map(m => (
        <div key={`${m.id}-${rounds}`} className="trailer-card">
          <img src={m.image || m.posterUrl || ""} alt={m.title} />
          <h4>{m.title}{m.year ? ` (${m.year})` : ""}</h4>
          {m.trailer ? (
            <iframe
              key={`iframe-${m.id}-${rounds}`}   // <-- force iframe re-mount
              src={m.trailer + `?rel=0&modestbranding=1&round=${rounds}`} // cache buster
              width="560" height="315" frameBorder={0} allowFullScreen
            />
          ) : <div className="no-trailer">Trailer unavailable</div>}
        </div>
      ))}
    </div>
  );
}


The -${rounds} in keys and the &round=${rounds} in the iframe URL guarantees the DOM updates even if the top few ids happen to be similar between rounds.

Why this will finally change

Genre-only: we only add +1 to the chosen movie’s TMDb genre ids. Nothing else can mask the signal.

Rotation per round: even if the same genres dominate, the window shifts every click, so the visible set changes.

No caching + re-mount keys: browser/React cannot reuse the previous iframes or list—new keys force a repaint.

If this still looks identical, it means the A/B choices share the same primary genres. Click a film from a clearly different genre (e.g., Animation vs Crime) and the next trailer set will flip.