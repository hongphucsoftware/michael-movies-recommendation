Why cant the app/program do this. Once the ab testing is done im assuming it then has a list of the movies it will show to the user in the form of trailers based on there testing. Why cant that list be then typed into search for the related youtube trailer?
ChatGPT said:
Thought for 40s

You’re right—that’s exactly what it should do:

finish A/B → 2) you get a ranked list of TMDB movie IDs → 3) for each movie, get a YouTube trailer by searching YouTube with the movie title/year when TMDB doesn’t already give a YouTube key.

Below is a drop-in server patch that does precisely that. It:

Tries TMDB videos first (YouTube only).

If none, opens YouTube search for "<title> <year> official trailer" and extracts the best video id from the page (no API key).

Returns an embed-ready URL ( /embed/… ) per movie.

Caches results for 24h so you don’t get rate-limited.

Paste this over the trailer section in your server/routes.ts (replace your current trailer helpers + /trailer + /trailers endpoints).

server/routes.ts — YouTube search fallback (copy/paste)
/* -------- Trailers: TMDB YouTube → else YouTube Search (embed URLs + cache) --------
   Replit/Agent NOTE:
   - Do NOT replace this with a small curated list or remove search fallback.
   - Policy: Always try TMDB for site=YouTube; if not found, search YouTube by title+year.
   - Returns EMBED URLs only (for iframes). Results cached for 24h.
------------------------------------------------------------------------------- */

function scoreTmdbVideo(v: any) {
  let s = 0;
  const type = (v.type || "").toLowerCase();
  if (type === "trailer") s += 4; else if (type === "teaser") s += 2;
  if (v.official) s += 3;
  if ((v.name || "").toLowerCase().includes("official")) s += 1;
  if (v.size) s += Math.min(3, Math.floor((v.size ?? 0) / 360));
  return s;
}

const ytEmbed = (id: string) => `https://www.youtube.com/embed/${id}?rel=0&modestbranding=1`;

const TRAILER_TTL_MS = 1000 * 60 * 60 * 24; // 24h
const trailerCache = new Map<number, { embed: string | null; at: number }>();

async function tmdbYouTubeKey(movieId: number): Promise<string | null> {
  const v1 = await tmdb(`/movie/${movieId}/videos`, { include_video_language: "en,null", language: "en-US" });
  let vids = (v1.results || []).filter((v: any) => v && v.key && String(v.site).toLowerCase() === "youtube");
  if (!vids.length) {
    const v2 = await tmdb(`/movie/${movieId}/videos`, {}); // full fallback
    vids = (v2.results || []).filter((v: any) => v && v.key && String(v.site).toLowerCase() === "youtube");
  }
  if (!vids.length) return null;
  const best = vids.sort((a: any, b: any) => scoreTmdbVideo(b) - scoreTmdbVideo(a))[0];
  return best?.key || null;
}

// Light-weight YouTube search without an API key.
// We fetch the results page and score the first ~40 videoIds by nearby keywords.
async function youtubeSearchVideoId(query: string, preferYear?: string): Promise<string | null> {
  const url = `https://www.youtube.com/results?hl=en&search_query=${encodeURIComponent(query)}`;
  const res = await fetch(url, {
    headers: {
      "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/121 Safari/537.36",
      "accept-language": "en-US,en;q=0.9",
      "accept": "text/html,application/xhtml+xml",
      "cache-control": "no-cache",
      "pragma": "no-cache",
      "referer": "https://www.youtube.com/",
    },
  });
  if (!res.ok) return null;
  const html = await res.text();

  const ids = Array.from(html.matchAll(/"videoId":"([a-zA-Z0-9_-]{11})"/g)).map(m => m[1]);
  const uniq: string[] = [];
  const seen = new Set<string>();
  for (const id of ids) { if (!seen.has(id)) { seen.add(id); uniq.push(id); } }
  const cand = uniq.slice(0, 40);
  if (!cand.length) return null;

  let best = cand[0], bestScore = -Infinity;
  for (const id of cand) {
    const idx = html.indexOf(id);
    const window = html.slice(Math.max(0, idx - 600), idx + 600).toLowerCase();
    let s = 0;
    if (window.includes("official")) s += 3;
    if (window.includes("trailer")) s += 3;
    if (window.includes("teaser")) s += 1;
    if (window.includes("4k") || window.includes("hd")) s += 1;
    // Negative cues
    if (window.includes("fan made")) s -= 3;
    if (window.includes("fan-made")) s -= 3;
    if (window.includes("music video")) s -= 3;
    if (window.includes("game")) s -= 2;
    // Year nudge
    if (preferYear && window.includes(preferYear)) s += 1;
    if (s > bestScore) { bestScore = s; best = id; }
  }
  return best;
}

async function bestYouTubeEmbedFor(movieId: number): Promise<string | null> {
  const now = Date.now();
  const cached = trailerCache.get(movieId);
  if (cached && now - cached.at < TRAILER_TTL_MS) return cached.embed;

  // 1) TMDB → YouTube
  let key = await tmdbYouTubeKey(movieId);

  // 2) If TMDB had none, search YT by "<title> <year> official trailer" then "<title> trailer"
  if (!key) {
    try {
      const meta = await tmdb(`/movie/${movieId}`, { language: "en-US" });
      const title = meta?.title || meta?.original_title || "";
      const year = (meta?.release_date || "").slice(0, 4);
      if (title) {
        key = await youtubeSearchVideoId(`${title} ${year} official trailer`, year);
        if (!key) key = await youtubeSearchVideoId(`${title} official trailer`, year);
        if (!key) key = await youtubeSearchVideoId(`${title} trailer`, year);
      }
    } catch { /* ignore */ }
  }

  const embed = key ? ytEmbed(key) : null;
  trailerCache.set(movieId, { embed, at: now });
  return embed;
}

// Single movie
api.get("/trailer", async (req: Request, res: Response) => {
  try {
    const id = Number(req.query.id);
    if (!id) return res.status(400).json({ ok: false, error: "Missing id" });
    if (!TMDB_API_KEY) return res.status(400).json({ ok: false, error: "TMDB_API_KEY not set" });

    const embed = await bestYouTubeEmbedFor(id);
    res.json({ ok: true, trailer: embed ? { embed } : null });
  } catch (e: any) {
    res.status(500).json({ ok: false, error: e?.message ?? String(e) });
  }
});

// Batch: /api/trailers?ids=1,2,3  → { trailers: { [id]: embed|null } }
api.get("/trailers", async (req: Request, res: Response) => {
  try {
    const ids = String(req.query.ids || "")
      .split(",")
      .map((x) => Number(x.trim()))
      .filter(Boolean)
      .slice(0, 50);

    if (!ids.length) return res.json({ ok: true, trailers: {} });

    const tasks = ids.map((id) => async () => ({ id, embed: await bestYouTubeEmbedFor(id) }));
    const out = await pLimit(CONCURRENCY, tasks);

    const map: Record<number, string | null> = {};
    out.forEach(({ id, embed }) => { map[id] = embed || null; });

    res.json({ ok: true, trailers: map });
  } catch (e: any) {
    res.status(500).json({ ok: false, error: e?.message ?? String(e) });
  }
});


What this does (and why it’s the right fit for your flow):

After A/B, you already have the 12 TMDB IDs.

For each ID we first ask TMDB for a YouTube trailer.

If TMDB has none, we search YouTube with the movie’s actual title + year and pick the best matching trailer.

You get a clean embed URL for the iframe; no broken players.

Your client code that calls /api/trailers?ids=… and embeds the returned URLs can stay as-is (use the version that expects embed URLs only).