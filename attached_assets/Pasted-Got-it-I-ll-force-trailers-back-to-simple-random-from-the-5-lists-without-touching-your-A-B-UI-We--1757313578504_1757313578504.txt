Got it. I’ll force trailers back to simple random-from-the-5-lists without touching your A/B UI. We’ll override just the two endpoints the client uses.

1) Add an override router (random 6 + simple trailer lookup)
cat > server/src/routes/override.ts <<'EOF'
import { Router } from "express";
import { getState } from "../state";
const TMDB_API = "https://api.themoviedb.org/3";
const TMDB_KEY = process.env.TMDB_API_KEY as string;

const r = Router();
const shuffle=<T>(a:T[])=>{for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}
const sample=<T>(arr:T[],n:number)=>shuffle([...arr]).slice(0,Math.min(n,arr.length));

type Vid={site?:string,type?:string,name?:string,key?:string};
const best=(vs:Vid[])=>{
  const ys=vs.filter(v=>(v.site||"").toLowerCase()==="youtube"&&v.key);
  if(!ys.length)return null;
  const rank=(v:Vid)=>{const t=(v.type||"").toLowerCase(),n=(v.name||"").toLowerCase();
    let s=0;if(t.includes("trailer"))s+=100;if(t.includes("teaser"))s+=60;if(t.includes("clip"))s+=40;if(n.includes("official"))s+=10;return s;}
  ys.sort((a,b)=>rank(b)-rank(a));return ys[0]||null;
}
async function trailerUrl(id:number){
  const fetchV=async(p:string)=>{try{const j=await fetch(`${TMDB_API}${p}&api_key=${TMDB_KEY}`).then(r=>r.json());
    if(Array.isArray(j?.results))return j.results as Vid[]; if(Array.isArray(j?.videos?.results))return j.videos.results as Vid[]; return [];}catch{return[]}}
  let v=await fetchV(`/movie/${id}/videos?`); if(!v.length) v=await fetchV(`/movie/${id}?append_to_response=videos&include_video_language=en,null`);
  const b=best(v); return b?.key ? `https://www.youtube.com/embed/${b.key}` : null;
}

/** FORCE SIMPLE: ignore votes; 6 random recs from allowed pool minus excludeIds */
r.post("/score-round", async (req,res)=>{
  const st=await getState();
  const excluded=new Set<number>((req.body?.excludeIds||[]) as number[]);
  const pool=st.all.filter(m=>!excluded.has(m.id));
  const recs=sample(pool,6);
  const trailers:Record<number,string|null>={};
  for(const m of recs){ trailers[m.id]=await trailerUrl(m.id); }
  res.json({ ok:true, recs, trailers, rationale:{summaryText:"Here are 6 picks from your five IMDb lists."}, reasonsPerMovie:{} });
});

/** Compat: trailers by ids */
r.get("/trailers", async (req,res)=>{
  const ids=String(req.query.ids||"").split(",").map(s=>Number(s.trim())).filter(Number.isFinite);
  const out:Record<number,string|null>={}; for(const id of ids){ out[id]=await trailerUrl(id); }
  res.json({ ok:true, trailers: out });
});

export default r;
EOF

2) Mount the override before your existing API (no UI changes)
applypatch << 'PATCH'
*** Begin Patch
*** Update File: server/src/index.ts
@@
-import api from "./routes/api";
+import api from "./routes/api";
+import override from "./routes/override";
@@
-app.use(express.json());
-// API FIRST
-app.use("/api", api);
+app.use(express.json());
+// OVERRIDE FIRST (wins), then the rest of API
+app.use("/api", override);
+app.use("/api", api);
*** End Patch
PATCH

3) Rebuild & run
npm run build
npm run start:prod


Now: finish 12 picks → you always get 6 trailers (random from the 5 lists, excluding the 24 A/B). Buttons (Next/Save/Watch now/etc.) keep working because the response shape didn’t change.