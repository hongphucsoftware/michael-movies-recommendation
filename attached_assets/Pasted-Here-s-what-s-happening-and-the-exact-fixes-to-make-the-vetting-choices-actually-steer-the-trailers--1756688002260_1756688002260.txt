Here’s what’s happening and the exact fixes to make the vetting choices actually steer the trailers (and stop the “Godfather / Goodfellas” loop).

What I found (quick)

You are passing your learned weights w into the trailer wheel (EnhancedTrailerWheelSection), and it does rank by dot(w, movie.features). So the plumbing is there.

Two things blunt the effect, causing sameness:

Feature vectors don’t capture “era”, so whether you pick lots of recent posters or classics, the vector is almost the same (mostly Crime/Drama).

The trailer wheel doesn’t include diversity — it always takes the top of the ranked list + tiny novelty. So once “Crime/Drama” wins early, it keeps serving similar titles.

Below are three surgical patches (copy/paste) that keep your current structure but make onboarding → trailers feel directly connected.

1) Add an “era” signal to features (lets 2020–2024 vs classics matter)
A) client/src/lib/imdbService.ts

Change your feature builder so it also encodes recentness (2020–2024). We’ll reuse the 12th slot (you don’t use “episode length” for movies), so DIMENSION stays 12.

Find the feature vector function and replace it with this version (note the extra releaseYear param and the new slot):

// Generate 12-dim vector from TMDb genre IDs + era (keeps DIMENSION=12)
private generateFeatureVector(genreIds: number[], releaseYear?: number): number[] {
  const has = (ids: number[]) => ids.some(g => genreIds.includes(g)) ? 1 : 0;

  const comedy = has(this.GENRES.Comedy);
  const drama  = has(this.GENRES.Drama);
  const action = has(this.GENRES.Action);
  const thrill = has([this.GENRES.Thriller, this.GENRES.Mystery, this.GENRES.Crime]);
  const scifi  = has(this.GENRES.SciFi);
  const fanim  = has([this.GENRES.Fantasy, this.GENRES.Animation]);
  const docu   = has(this.GENRES.Documentary);

  const light  = Math.min(1, comedy*0.8 + fanim*0.4 + has([this.GENRES.Family])*0.6 + has([this.GENRES.Romance])*0.4);
  const dark   = Math.min(1, thrill*0.6 + drama*0.4 + has([this.GENRES.Horror])*0.8 + has([this.GENRES.Crime])*0.5);
  const fast   = Math.min(1, action*0.8 + thrill*0.6 + scifi*0.4 + fanim*0.3);
  const slow   = Math.min(1, drama*0.6 + docu*0.4);

  // Slot 12 = “recentness” (movies only)
  const recent = (releaseYear && releaseYear >= 2020) ? 1 : 0;

  return [comedy, drama, action, thrill, scifi, fanim, docu, light, dark, fast, slow, recent];
}


Then, where you construct each Movie, pass the year:

const yearNum = parseInt((details.release_date || "0").slice(0,4), 10) || undefined;
// ...
features: this.generateFeatureVector(genreIds, yearNum),

B) client/src/lib/catalogueService.ts

Do the same tweak (the helper there already computes a vector; add the releaseYear like above and pass it where you push each movie):

const yearNum = parseInt((r.release_date || "0").slice(0,4), 10) || undefined;
features: this.generateFeatureVector(r.genre_ids || [], "movie", yearNum)


…and update the signature:

private generateFeatureVector(genreIds: number[], type: string, releaseYear?: number): number[] {
  // same math as above; last slot = (releaseYear >= 2020 ? 1 : 0)
}


Why this matters: your onboarding choices now push weights toward recent vs classic as well as genre. That’s the missing axis when you combine “Top all time” with “Best 2020–2024.”

2) Make the trailer queue diversify (so you don’t get 5 crime epics in a row)
client/src/components/EnhancedTrailerWheelSection.tsx

Add a small MMR-style diversity term against the last few shown items. This keeps the top picks but spaces out similar ones.

At the top (imports remain the same), add helpers:

function dot(a:number[], b:number[]){ return a.reduce((s,v,i)=> s + (v||0)*(b[i]||0), 0); }
function norm(a:number[]){ return Math.sqrt(dot(a,a)) || 1; }
function cosine(a:number[], b:number[]){ return dot(a,b) / (norm(a)*norm(b)); }


Add state to remember recent features:

const [recentHistory, setRecentHistory] = useState<Movie[]>([]);


Update showNext (or wherever you advance) to push history:

const showNext = useCallback((options?: { skip?: boolean; save?: boolean; hide?: boolean }) => {
  if (!currentMovie) return;
  // ... existing save/hide/recent code ...
  setRecentHistory(prev => [currentMovie, ...prev].slice(0, 6)); // keep last 6
  // ... rest unchanged ...
}, [currentMovie, queue, onSave, onHide, onMarkRecent]);


Now change the ranking to subtract a diversity penalty:

const rankMovies = useCallback(() => {
  const available = getAvailableMovies();
  if (available.length === 0) return [];

  // Precompute an "average recent vector" for diversity
  let recentVec: number[] | null = null;
  if (recentHistory.length > 0) {
    const d = recentHistory[0].features.length;
    const sum = new Array(d).fill(0);
    recentHistory.forEach(m => {
      m.features.forEach((v, i) => sum[i] += (v || 0));
    });
    recentVec = sum.map(v => v / recentHistory.length);
  }

  const LAMBDA = 0.25; // diversity strength (tweak 0.2–0.35)

  const scored = available.map(movie => {
    const base = sigmoid(dotProduct(preferences.w, movie.features));
    const nov  = calculateNovelty(movie);
    const div  = recentVec ? -LAMBDA * Math.max(0, cosine(movie.features, recentVec)) : 0;
    return { movie, score: base + nov + div };
  });

  scored.sort((a,b) => b.score - a.score);

  // epsilon-greedy exploration unchanged
  if (Math.random() < explorationRate && scored.length > 6) {
    const k = 3 + Math.floor(Math.random() * Math.min(12, scored.length - 1));
    [scored[0], scored[k]] = [scored[k], scored[0]];
  }
  return scored.map(s => s.movie);
}, [getAvailableMovies, preferences.w, calculateNovelty, explorationRate, recentHistory]);


Result: you still respect the learned preferences, but you avoid back-to-back near-duplicates.

3) Make onboarding changes show up immediately + stop “stale weights” confusion

Right now, preferences are saved to a single localStorage key. If you switch catalogue (classics vs 2020s), you can end up applying weights learned on the previous pool.

Two options (both easy):

Option A (quick): show a “New pool detected — reset learning?” prompt

Call your existing reset() when you detect the pool changed significantly (e.g., different count or different category mix). This is one line in useEnhancedCatalogue after you load movies:

// After you set movies in state:
if (movies.some(m => m.category === 'recent')) {
  // new pool flavour; raise exploration a bit and/or reset
  // raise exploration so the queue adapts quickly
  adjustAdventurousness(+0.08); 
}


…and add a “Reset learning” CTA (you already have a Reset button).

Option B (better): namespace storage by pool key

In useMLLearning.ts, change the storage keys from 'ts_preferences' to include a catalogue key (e.g., 'enhanced_v1'):

const STORAGE_KEY = 'ts_preferences_enhanced_v1'; // top100+2020s
// use STORAGE_KEY in localStorage.getItem/setItem instead of 'ts_preferences'


That way classics-only and classics+2020s don’t share weights.

Bonus (trailer quality)

You already fetch TMDb videos; make sure you pick the best one (official full trailer). If you haven’t added this yet, drop it where you select v:

function pickBestYouTubeVideo(results: any[]): any | null {
  const YT = results.filter(r => r.site === "YouTube");
  if (!YT.length) return null;
  const score = (v:any) => {
    const n = (v.name||"").toLowerCase();
    let s = 0;
    if (v.type === "Trailer") s += 6;
    if (v.official === true) s += 5;
    if (/\bofficial\b/.test(n)) s += 3;
    if (/\btrailer\b/.test(n)) s += 2;
    if (v.size >= 1080) s += 2; else if (v.size >= 720) s += 1;
    if (/\bteaser\b/.test(n)) s -= 2;
    if (/\bclip\b/.test(n)) s -= 3;
    if (/\bspot\b/.test(n)) s -= 2;
    return s;
  };
  return YT.map(v => ({v, s: score(v)})).sort((a,b)=>b.s-a.s)[0]?.v || null;
}


Use it instead of the first Trailer/Teaser.