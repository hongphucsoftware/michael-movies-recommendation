What I’m doing (summary for Replit)

Stop dev/hot-reload loop. Run a production build only.

Ensure every movie has real TMDb genres (pull /movie/{id}?append_to_response=credits).

Make A/B clicks only update genre counts.

Rank recommendations only by genre counts (with a tiny round-based rotation so the visible list changes each click).

Return fresh recs immediately from /api/ab/vote, then fetch trailers for those ids.

No caching anywhere on recs/trailers responses.

1) Replit config (no more dev loop)
Edit .replit
# .replit
run = "npm run start:prod"

Edit package.json scripts
{
  "scripts": {
    "build": "tsc -b && vite build",
    "start:prod": "NODE_ENV=production node dist/server/index.js"
  }
}


Run in Shell:

npm run build


Then click Run (it should execute start:prod, not a dev watcher).

2) Server patch (genre-only learning + fresh recs each vote)

File: server/routes.ts (replace/add the shown pieces; keep your existing catalogue builder and /api/catalogue for A/B pool)

2.1 Top helpers (session + no-store)
// --- Session & no-cache helpers ---
type GenreId = number;
type GenreProfile = { genreScores: Record<GenreId, number>; rounds: number; seenPairs: Set<string> };
const PROFILES = new Map<string, GenreProfile>();

function sess(req: import("express").Request): GenreProfile {
  const sid = (req.headers["x-session-id"] as string) || (req.query.sid as string) || "anon";
  let p = PROFILES.get(sid);
  if (!p) { p = { genreScores: {}, rounds: 0, seenPairs: new Set() }; PROFILES.set(sid, p); }
  return p;
}
function noStore(res: import("express").Response) {
  res.setHeader("Cache-Control", "no-store, no-cache, must-revalidate, max-age=0");
  res.setHeader("Pragma", "no-cache");
  res.setHeader("Vary", "x-session-id");
}

2.2 Ensure genres get populated from TMDb details

Add (or replace your resolver) so genres never stays empty:

const TMDB = "https://api.themoviedb.org/3";
const IMG  = "https://image.tmdb.org/t/p";
const POSTER = "w500", BACKDROP = "w780";
const TMDB_KEY = process.env.TMDB_API_KEY || "";

type TMDbSearchHit = { id:number; title?:string; original_title?:string; release_date?:string; poster_path?:string|null; backdrop_path?:string|null; vote_average?:number; vote_count?:number; popularity?:number; adult?:boolean; genre_ids?:number[] };
type TMDbDetails = {
  id:number; title?:string; original_title?:string; overview?:string;
  release_date?:string; poster_path?:string|null; backdrop_path?:string|null;
  vote_average?:number; vote_count?:number; popularity?:number;
  genres?: { id:number; name:string }[];
};

async function tmdbSearch(title: string, year?: number): Promise<TMDbSearchHit|null> {
  const u = `${TMDB}/search/movie?api_key=${encodeURIComponent(TMDB_KEY)}&query=${encodeURIComponent(title)}${year?`&year=${year}`:""}`;
  const r = await fetch(u); if (!r.ok) return null;
  const j:any = await r.json(); const hits:TMDbSearchHit[] = j?.results || [];
  if (!hits.length) return null;
  const exact = year ? hits.find(h => (h.release_date||"").startsWith(String(year))) : null;
  return exact || hits[0];
}
async function tmdbDetails(id:number): Promise<TMDbDetails|null> {
  const u = `${TMDB}/movie/${id}?api_key=${encodeURIComponent(TMDB_KEY)}&append_to_response=credits`;
  const r = await fetch(u); if (!r.ok) return null;
  return await r.json();
}

// Replace your resolveRaw() with this:
async function resolveRaw(raw: { title:string; year?:number; srcList:string }): Promise<Item|null> {
  const hit = await tmdbSearch(raw.title, raw.year);
  if (!hit || hit.adult) return null;
  const det = await tmdbDetails(hit.id); if (!det) return null;

  const genres = (det.genres || []).map(g => g.id);
  return {
    id: det.id,
    title: (det.title || det.original_title || raw.title).trim(),
    year: raw.year,
    genres, // <— IMPORTANT
    posterUrl: det.poster_path ? `${IMG}/${POSTER}${det.poster_path}` : null,
    backdropUrl: det.backdrop_path ? `${IMG}/${BACKDROP}${det.backdrop_path}` : null,
    overview: (det as any).overview || "",
    popularity: det.popularity || 0,
    voteAverage: det.vote_average || 0,
    voteCount: det.vote_count || 0,
    sources: [raw.srcList],
  };
}

2.3 Genre-only ranking with visible rotation
function scoreByGenres(genres: number[]|undefined, gp: GenreProfile): number {
  let s = 0; for (const g of genres || []) s += gp.genreScores[g] || 0; return s;
}
function seedSortKey(id: number, rounds: number) {
  return ((id * 1103515245 + 12345 + rounds * 1337) >>> 0) / 2**32;
}
function rankRecsByGenre(gp: GenreProfile, topN: number): Item[] {
  const pool = CATALOGUE.filter(x => !AB_SET.has(x.id));
  if (gp.rounds === 0) {
    return pool.slice().sort((a,b) =>
      ((b.voteAverage||0)*Math.log(1+(b.voteCount||1))) - ((a.voteAverage||0)*Math.log(1+(a.voteCount||1)))
    ).slice(0, topN);
  }
  const ranked = pool.map(it => ({
    it,
    s: scoreByGenres(it.genres, gp),
    j: seedSortKey(it.id, gp.rounds), // tie-break changes each round
  }))
  .sort((a,b) => (b.s - a.s) || (b.j - a.j))
  .map(x => x.it);

  // rotate window so visible set changes even if top genres tie
  const window = Math.min(8, Math.max(1, Math.floor(topN/3)));
  const offset = (gp.rounds % 5) * window;
  return ranked.slice(offset).concat(ranked.slice(0, offset)).slice(0, topN);
}

2.4 Replace /api/ab/vote to learn genres and return fresh recs
api.post("/api/ab/vote", import("express").json(), async (req, res) => {
  noStore(res);
  const { leftId, rightId, chosenId } = req.body as { leftId:number; rightId:number; chosenId:number };
  const p = sess(req);
  const chosen = CATALOGUE.find(i => i.id === chosenId);
  if (!chosen) return res.status(400).json({ ok:false, error:"bad chosenId" });

  // genre-only learning
  for (const g of (chosen.genres || [])) p.genreScores[g] = (p.genreScores[g] || 0) + 1;
  p.rounds += 1;

  const recItems = rankRecsByGenre(p, 20).map(t => ({
    id: t.id, title: t.title, year: t.year,
    image: t.posterUrl || t.backdropUrl,
    posterUrl: t.posterUrl, backdropUrl: t.backdropUrl, genres: t.genres
  }));
  return res.json({
    ok: true,
    rounds: p.rounds,
    topGenres: Object.entries(p.genreScores).sort((a,b)=>b[1]-a[1]).slice(0,5),
    recs: recItems
  });
});

2.5 No-cache trailers too
api.get("/api/trailers", async (req, res) => {
  noStore(res);
  // ... keep your existing TMDb videos → YouTube embed batching
});

3) Client: after a vote, use the fresh list the server returns

In your A/B component’s click handler, replace the vote logic with:

import { useState } from "react";

const sid = (localStorage.getItem("paf.sid")) || (() => {
  const s = "sid_" + Math.random().toString(36).slice(2);
  localStorage.setItem("paf.sid", s);
  return s;
})();

const [recModel, setRecModel] = useState<{ rounds:number; items:any[] }>({ rounds: 0, items: [] });

async function onChoose(leftId:number, rightId:number, chosenId:number) {
  const vote = await fetch(`/api/ab/vote?sid=${sid}`, {
    method: "POST",
    headers: { "Content-Type":"application/json", "Cache-Control":"no-store", "x-session-id": sid },
    cache: "no-store",
    body: JSON.stringify({ leftId, rightId, chosenId })
  }).then(r=>r.json());

  if (!vote?.ok) return;

  const ids = vote.recs.map((m:any)=>m.id).join(",");
  const tr = await fetch(`/api/trailers?sid=${sid}&ids=${encodeURIComponent(ids)}&t=${Date.now()}`, {
    headers: { "Cache-Control":"no-store" }, cache: "no-store"
  }).then(r=>r.json());

  const withTrailers = vote.recs.map((m:any)=>({ ...m, trailer: tr.trailers?.[m.id] ?? null }));
  setRecModel({ rounds: vote.rounds, items: withTrailers });
}


Render the trailer strip with keys that include rounds so iframes re-mount:

function TrailerStrip({ model }: { model:{ rounds:number; items:any[] } }) {
  const { rounds, items } = model;
  return (
    <div className="trailer-strip">
      {items.map(m => (
        <div key={`${m.id}-${rounds}`} className="trailer-card">
          <img src={m.image || m.posterUrl || ""} alt={m.title} />
          <h4>{m.title}{m.year ? ` (${m.year})` : ""}</h4>
          {m.trailer ? (
            <iframe
              key={`ifr-${m.id}-${rounds}`}
              src={`${m.trailer}?round=${rounds}`}
              width="560" height="315" frameBorder={0} allowFullScreen
            />
          ) : <div className="no-trailer">Trailer unavailable</div>}
        </div>
      ))}
    </div>
  );
}


No other UI changes are required. You’re just swapping in the fresh list the server returns after each vote.

4) Quick tests (prove it works)

Genres present: add temporarily in server after build:

console.log("emptyGenreCount", CATALOGUE.filter(x=>!x.genres || x.genres.length===0).length);


Expect near 0. If high → TMDb key wrong or resolver not used.

Vote once on an obvious genre (e.g., Animation). The next JSON from /api/ab/vote includes:

rounds: 1

topGenres: [[<genreId>,1], ...]

recs: [...] (different list)
And you should see different trailers (new iframe keys).

No “same list” after 2 clicks: the rotation (offset) + new counts will change ordering each round.

That’s it. This is as dumb-simple and deterministic as it gets: genre counters only, fresh list per vote, no cache, prod server, visible rotation. If Replit still shows identical trailers after this, it means your client isn’t rendering the returned recs from /api/ab/vote; wire the setRecModel into whatever component paints the trailer list.