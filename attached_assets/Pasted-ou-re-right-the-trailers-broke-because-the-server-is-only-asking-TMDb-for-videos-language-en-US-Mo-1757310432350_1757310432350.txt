ou’re right: the trailers broke because the server is only asking TMDb for videos?language=en-US.
Most movies on your 5 IMDb lists (esp. non-US titles) don’t have an EN video, so TMDb returns zero results → your strip shows nothing.

Fix (tiny, safe, no UI changes)

Make the trailer resolver try multiple fallbacks and pick the best YouTube video:

videos?language=en-US

videos (no language)

movie/{id}?append_to_response=videos&include_video_language=en,null

Then choose in this order: Official Trailer > Trailer > Teaser > Clip (YouTube only).

Paste in Replit shell
applypatch << 'PATCH'
*** Begin Patch
*** Update File: server/src/routes/api.ts
@@
 const TMDB_API = "https://api.themoviedb.org/3";
 const TMDB_KEY = process.env.TMDB_API_KEY as string;
 
 const api = Router();
@@
 const sample  = <T>(arr:T[], n:number)=> shuffle([...arr]).slice(0, Math.min(n, arr.length));
 const normPop = (p:number, min:number, max:number)=> max<=min ? 0.5 : (p-min)/(max-min);
@@
+/* ---------- Robust trailer resolver (YouTube only) ---------- */
+type Vid = { site?: string; type?: string; name?: string; key?: string };
+function pickBestVideo(vs: Vid[]): Vid | null {
+  const ys = vs.filter(v => (v.site||"").toLowerCase()==="youtube" && v.key);
+  if (!ys.length) return null;
+  // Score: Official Trailer > Trailer > Teaser > Clip ; "Official" in name boosts
+  const rank = (v: Vid) => {
+    const t = (v.type||"").toLowerCase();
+    const n = (v.name||"").toLowerCase();
+    let s = 0;
+    if (t.includes("trailer")) s += 100;
+    if (t.includes("teaser"))  s += 60;
+    if (t.includes("clip"))    s += 40;
+    if (n.includes("official")) s += 10;
+    return s;
+  };
+  ys.sort((a,b)=>rank(b)-rank(a));
+  return ys[0] || null;
+}
+
+async function getTrailerUrl(movieId: number): Promise<string|null> {
+  const tryFetch = async (path: string) => {
+    try {
+      const j = await fetch(`${TMDB_API}${path}&api_key=${TMDB_KEY}`).then(r=>r.json());
+      if (Array.isArray(j?.results)) return j.results as Vid[];
+      if (Array.isArray(j?.videos?.results)) return j.videos.results as Vid[];
+      return [];
+    } catch { return []; }
+  };
+  // 1) EN only
+  let vids = await tryFetch(`/movie/${movieId}/videos?language=en-US`);
+  // 2) any language
+  if (!vids.length) vids = await tryFetch(`/movie/${movieId}/videos?`);
+  // 3) appended with include_video_language
+  if (!vids.length) vids = await tryFetch(`/movie/${movieId}?append_to_response=videos&language=en-US&include_video_language=en,null`);
+  const best = pickBestVideo(vids);
+  return best?.key ? `https://www.youtube.com/embed/${best.key}` : null;
+}
@@
-  const trailers: Record<number,string|null> = {};
-  for (const m of picks) {
-    try {
-      const r = await fetch(`${TMDB_API}/movie/${m.id}/videos?language=en-US&api_key=${TMDB_KEY}`).then(r=>r.json());
-      const vids = Array.isArray(r?.results) ? r.results : [];
-      const yt = vids.find((v:any)=> v.site==="YouTube" && /Trailer|Teaser|Official|Clip/i.test(`${v.type} ${v.name}`) && v.key);
-      trailers[m.id] = yt ? `https://www.youtube.com/embed/${yt.key}` : null;
-    } catch { trailers[m.id] = null; }
-  }
+  const trailers: Record<number,string|null> = {};
+  for (const m of picks) { trailers[m.id] = await getTrailerUrl(m.id); }
@@
 api.get("/trailers", async (req,res)=>{
   noStore(res);
   const ids = String(req.query.ids||"").split(",").map(s=>Number(s.trim())).filter(n=>Number.isFinite(n));
   const out: Record<number,string|null> = {};
-  for (const id of ids){
-    try{
-      const r = await fetch(`${TMDB_API}/movie/${id}/videos?language=en-US&api_key=${TMDB_KEY}`).then(r=>r.json());
-      const vids = Array.isArray(r?.results)? r.results : [];
-      const yt = vids.find((v:any)=> v.site==="YouTube" && /Trailer|Teaser|Official|Clip/i.test(`${v.type} ${v.name}`) && v.key);
-      out[id] = yt ? `https://www.youtube.com/embed/${yt.key}` : null;
-    }catch{ out[id]=null; }
-  }
+  for (const id of ids){ out[id] = await getTrailerUrl(id); }
   res.json({ ok:true, trailers: out });
 });
*** End Patch
PATCH


Then rebuild:

npm run build
npm run start:prod