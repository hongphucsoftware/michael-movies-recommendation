ok so we are very close now. We have youtube trailers. The final step is to check that the movies correlate to the ab testing that was done as the movies trailers i see now a very generic ie batman, batman begins, scarface, heat & Leon the professional. Ive tried it 3 times and no the trailers are not correlating to the ab test. This is the last piece of the puzzle. I need you to look at replits code and rewrite what you need to. The movies, again, should be a selection of 5 movies that relate to the users tested preferences and be used off the 3 urls i sent. They can come from anywhere on these lists (looks like at the moment replit is pulling them from the top over and over again with no relation to the users ab test). Give it rules if you have to but this part must work and be a random selection of 5 movies from the list that correlate with the ab test results
ChatGPT said:

You’re right — the last missing piece is the picker logic: it still favors “generic/popular” titles instead of what the A/B test actually taught us. Below is a tight, copy-paste replacement that:

builds a profile from your A/B picks (genre weights + vector centroid),

scores the whole catalogue (from your 3 lists) with genre bias + cosine similarity,

samples 5 trailers from the top slice using a softmax (so each round is fresh, but still on-taste),

de-dupes (no repeated titles/brands), and

keeps the one-at-a-time trailer viewer (no grids).

This is just the client-side selector; your server already returns the full catalogue and the trailer embed URLs.

1) Replace client/src/components/TrailerPlayer.tsx with this version

This drops in cleanly and keeps the same props you already wired (items, learnedVec, recentChosenIds, …).

// TrailerPlayer — shows ONE trailer at a time, from a queue of 5 picked by A/B signal.
// Replit Agent: DO NOT convert this into a poster grid. Keep one-at-a-time playback.

import { useEffect, useMemo, useState, useCallback } from "react";
import type { Title } from "../hooks/useEnhancedCatalogue";
import { toFeatureVector, bestImageUrl } from "../hooks/useEnhancedCatalogue";

// ---------- math helpers ----------
const l2 = (x: number[]) => Math.sqrt(x.reduce((s, v) => s + v*v, 0));
const cosine = (a: number[], b: number[]) => {
  const la = l2(a), lb = l2(b); if (!la || !lb) return 0;
  let dot = 0; const n = Math.min(a.length, b.length);
  for (let i = 0; i < n; i++) dot += a[i]*b[i];
  return dot / (la * lb);
};

// tiny deterministic jitter so ties don’t clump
const jitterById = (id: number) => {
  const x = Math.sin(id * 99991) * 10000;
  return (x - Math.floor(x)) * 0.01;
};

// ---------- server call ----------
async function fetchTrailerEmbeds(ids: number[]): Promise<Record<number, string|null>> {
  if (!ids.length) return {};
  // Keep commas unencoded; server also tolerates encoded.
  const r = await fetch(`/api/trailers?ids=${ids.join(",")}`);
  if (!r.ok) return {};
  const j = await r.json();
  const out: Record<number, string|null> = {};
  Object.keys(j?.trailers || {}).forEach(k => (out[Number(k)] = j.trailers[k]));
  return out;
}

// ---------- user profile from picks ----------
type UserProfile = {
  vec: number[];                     // preference vector (centroid of picks)
  genreWeight: Record<number, number>; // TMDB genreId -> weight [0..1]
};

function buildUserProfile(items: Title[], chosenIds: number[]): UserProfile {
  const byId = new Map<number, Title>();
  for (const t of items) byId.set(t.id, t);

  // 1) Preference vector = normalized average of picked feature vectors
  const chosen: Title[] = chosenIds.map(id => byId.get(id)).filter(Boolean) as Title[];
  let vec: number[] = [];
  if (chosen.length) {
    const dim = (chosen[0].feature || toFeatureVector(chosen[0])).length;
    vec = new Array(dim).fill(0);
    for (const t of chosen) {
      const f = t.feature || toFeatureVector(t);
      for (let i = 0; i < dim; i++) vec[i] += f[i];
    }
    const norm = l2(vec) || 1;
    vec = vec.map(v => v / norm);
  }

  // 2) Genre weights with Laplace smoothing
  const counts: Record<number, number> = {};
  let total = 0;
  for (const t of chosen) {
    for (const g of (t.genres || [])) { counts[g] = (counts[g] || 0) + 1; total++; }
  }
  const uniqueGenres = Object.keys(counts).length || 1;
  const alpha = 0.5; // smoothing
  const genreWeight: Record<number, number> = {};
  // normalize to [0..1]
  for (const g of Object.keys(counts).map(Number)) {
    const w = (counts[g] + alpha) / (total + alpha * uniqueGenres);
    genreWeight[g] = w;
  }
  return { vec, genreWeight };
}

// Weighted sample without replacement using softmax over scores
function softmaxSample<T>(items: T[], getScore: (t: T)=>number, k: number, temperature = 0.7): T[] {
  const pool = items.slice();
  const out: T[] = [];
  for (let pick = 0; pick < k && pool.length; pick++) {
    const scores = pool.map(getScore);
    const max = Math.max(...scores);
    const exps = scores.map(s => Math.exp((s - max) / Math.max(temperature, 1e-6)));
    const sum = exps.reduce((a,b)=>a+b, 0) || 1;
    let r = Math.random() * sum;
    let idx = 0;
    for (; idx < exps.length; idx++) { r -= exps[idx]; if (r <= 0) break; }
    const chosen = pool.splice(Math.min(idx, pool.length-1), 1)[0];
    out.push(chosen);
  }
  return out;
}

type Props = {
  items: Title[];            // full catalogue (3 source lists)
  learnedVec: number[];      // from A/B learning
  recentChosenIds: number[]; // ids the user picked in A/B
  avoidIds?: number[];       // optional: avoid repeating
  count?: number;            // #trailers to queue (default 5)
};

export default function TrailerPlayer({
  items, learnedVec, recentChosenIds, avoidIds = [], count = 5,
}: Props) {
  const [queue, setQueue] = useState<Title[]>([]);
  const [embeds, setEmbeds] = useState<Record<number, string|null>>({});
  const [idx, setIdx] = useState(0);

  // --------- PICK 5 THAT MATCH THE PROFILE ----------
  const picks = useMemo(() => {
    // 0) Unique pool from the 3 lists
    const avoid = new Set<number>(avoidIds);
    const byId = new Map<number, Title>();
    for (const t of items) if (bestImageUrl(t)) byId.set(t.id, t);
    const pool0 = Array.from(byId.values()).filter(t => !avoid.has(t.id));

    // 1) Build user profile
    const profile = buildUserProfile(pool0, recentChosenIds);
    let u = learnedVec && l2(learnedVec) > 0.05 ? learnedVec.slice() : profile.vec.slice();
    const uNorm = l2(u);
    const useCosine = uNorm > 0.05;
    if (!useCosine) u = []; // fall back to genre-only if nothing learned

    // 2) Score = 0.55*cosine + 0.40*genreBias + 0.05*jitter – small anti-pop for low similarity
    const genreBias = (t: Title) => {
      const ids = t.genres || [];
      if (!ids.length) return 0;
      let s = 0;
      for (const g of ids) s += profile.genreWeight[g] || 0;
      return s / ids.length; // avg weight
    };

    const brandKey = (t: Title) =>
      (t.title || "").toLowerCase().replace(/[^a-z0-9]+/g, " ").split(" ").slice(0, 2).join(" ");

    const scored = pool0.map(t => {
      const f = t.feature || toFeatureVector(t);
      const rel = useCosine ? cosine(f, u) : 0;
      const gb  = genreBias(t);
      const base = 0.55*rel + 0.40*gb + 0.05*jitterById(t.id);
      // If not a great match, nudge down super popular titles so we explore within-user taste
      const pop = Math.min(1, (t.popularity || 0) / 100);
      const antiPop = (rel < 0.35 && gb < 0.35) ? -(0.12 * pop) : 0;
      return { t, s: base + antiPop, brand: brandKey(t) };
    });

    // 3) Take a TOP SLICE by score, then softmax-sample 5 → fresh but on-taste
    const topSlice = scored.sort((a,b)=>b.s-a.s).slice(0, Math.min(250, scored.length));

    // 4) Enforce brand diversity (e.g., only one “batman”)
    const capPerBrand = 1;
    const filtered: typeof topSlice = [];
    const brandCount = new Map<string, number>();
    for (const it of topSlice) {
      const c = brandCount.get(it.brand) || 0;
      if (c >= capPerBrand) continue;
      brandCount.set(it.brand, c+1);
      filtered.push(it);
    }

    // 5) Softmax sample 5 without replacement (temperature controls variety)
    const sampled = softmaxSample(filtered, x => x.s, count, 0.65).map(x => x.t);
    return sampled;
  }, [items, JSON.stringify(recentChosenIds), JSON.stringify(avoidIds), JSON.stringify(learnedVec), count]);

  // --------- prefetch embeds and set initial playable trailer ----------
  useEffect(() => {
    let mounted = true;
    (async () => {
      setQueue(picks);
      const ids = picks.map(p => p.id);
      const map = await fetchTrailerEmbeds(ids);
      if (!mounted) return;
      setEmbeds(map);
      // start on the first playable trailer if available
      const first = picks.findIndex(p => map[p.id]);
      setIdx(first >= 0 ? first : 0);
    })();
    return () => { mounted = false; };
  }, [JSON.stringify(picks.map(p => p.id))]);

  // --------- controls ----------
  const canPrev = idx > 0;
  const canNext = idx + 1 < queue.length;
  const prev = useCallback(() => { if (canPrev) setIdx(i => Math.max(0, i-1)); }, [canPrev]);
  const next = useCallback(() => { if (canNext) setIdx(i => Math.min(queue.length-1, i+1)); }, [canNext]);

  // keyboard shortcuts
  useEffect(() => {
    const onKey = (e: KeyboardEvent) => { if (e.key === "ArrowLeft") prev(); if (e.key === "ArrowRight") next(); };
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [prev, next]);

  const current = queue[idx];
  const embed = current ? embeds[current.id] : null;

  return (
    <div className="w-full max-w-5xl mx-auto">
      <div className="flex items-center justify-between mb-3">
        <h2 className="text-xl font-semibold">Your Trailer Reel</h2>
        <div className="text-xs opacity-60">{idx + 1} / {queue.length}</div>
      </div>

      {current && (
        <div className="mb-3">
          <div className="text-lg font-medium mb-2">{current.title}</div>
          <div className="aspect-video w-full rounded-xl overflow-hidden bg-black">
            {embed ? (
              <iframe
                className="w-full h-full"
                src={embed}
                title={`Trailer: ${current.title}`}
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                allowFullScreen
              />
            ) : (
              <div className="w-full h-full flex items-center justify-center text-sm opacity-80">
                No trailer found for this title
              </div>
            )}
          </div>
        </div>
      )}

      <div className="flex gap-2">
        <button
          onClick={prev}
          disabled={!canPrev}
          className={`px-3 py-2 rounded-lg ${canPrev ? "bg-neutral-800 hover:bg-neutral-700" : "bg-neutral-900 opacity-50 cursor-not-allowed"}`}>
          ← Back
        </button>
        <button
          onClick={next}
          disabled={!canNext}
          className={`px-3 py-2 rounded-lg ${canNext ? "bg-neutral-800 hover:bg-neutral-700" : "bg-neutral-900 opacity-50 cursor-not-allowed"}`}>
          Next →
        </button>
      </div>
    </div>
  );
}


What changed vs. your previous picker

We derive genre weights from the A/B picks and blend them with the cosine similarity to your learned vector:
score = 0.55 * cosine + 0.40 * genreBias + 0.05 * jitter − antiPop

We cap brand repetition (capPerBrand = 1) so you don’t see “Batman, Batman Begins, …” in a 5-pack.

We take a top slice (up to 250 by score) and softmax-sample 5 → random, but on-taste. That stops the “always the same five” effect while staying aligned with the A/B signal.

2) Where to render it

Wherever you currently switch to results after the 12 A/B rounds, keep rendering this TrailerPlayer (not a grid) exactly like:

<TrailerPlayer
  items={catalogue.items}          // full list (3 URLs)
  learnedVec={learned}             // vector from your A/B learner
  recentChosenIds={abHistory.ids}  // IDs picked during A/B
  avoidIds={abHistory.allSeenIds}  // optional, to avoid repeats across rounds
  count={5}
/>

Quick validation (what you should see now)

If you pick a lot of animation in A/B, your 5-pack should skew to animation across all three lists (not just “top”).

If you pick crime/drama, you’ll still get variety — but no more 3–4 Batman variants.

Each new round stays within taste, but won’t repeat the same five every time.