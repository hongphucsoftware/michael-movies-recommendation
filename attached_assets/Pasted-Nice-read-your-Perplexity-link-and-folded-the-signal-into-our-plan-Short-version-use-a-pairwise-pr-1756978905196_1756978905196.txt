Nice—read your Perplexity link and folded the signal into our plan. Short version: use a pairwise preference model (BTL/Thurstone), pick the next question with active learning (info-gain/uncertainty), and post-test re-rank with MMR for diversity. That’s exactly the lane we’re in.  ￼ ￼ ￼ ￼ ￼ ￼ ￼

Here are tight, drop-in pieces to stop “random, irrelevant” pairs and make the tester behave:

1) Lock the test pool

Use the hard anchor list I gave you and gate the 12 rounds to that list only (no catalogue spillover). Set ANCHOR_MODE="hardlist" and sample only from /config/paf_anchor_hardlist.json.

2) BTL learner (online, bounded & stable)

// btl.ts
export type BTLState = {
  theta: Record<string, number>;     // taste score per title
  info:  Record<string, number>;     // ~Fisher info accumulator
};
const ETA = 0.35, L2 = 1e-3;

export function updateBTL(s: BTLState, winner: string, loser: string) {
  const ti = s.theta[winner] ?? 0, tj = s.theta[loser] ?? 0;
  const z = ti - tj;
  const p = 1 / (1 + Math.exp(-z));          // P(winner beats loser)  (BTL) 
  const g = 1 - p;                            // gradient magnitude
  // SGD step with tiny L2 to keep scores bounded
  s.theta[winner] = ti + ETA * (g - L2 * ti);
  s.theta[loser]  = tj - ETA * (g + L2 * tj);
  // track curvature to estimate uncertainty (p*(1-p) is local Fisher info)
  s.info[winner] = (s.info[winner] ?? 0) + p * (1 - p);
  s.info[loser]  = (s.info[loser]  ?? 0) + p * (1 - p);
}

export function uncertainty(s: BTLState, id: string) {
  const I = s.info[id] ?? 1e-6;
  return 1 / Math.sqrt(I); // larger => more uncertain (see BTL variance intuition)
}

(Why this works: BTL models pairwise choices by log-odds equal to score differences; uncertainty comes from the local curvature/Fisher info around each item.  ￼ ￼)

3) Active pair picker: uncertainty × feature-distance

// pair_pick.ts
type Vec = number[];
export function cosine(a: Vec, b: Vec) {
  let dp=0, na=0, nb=0; for (let i=0;i<a.length;i++){dp+=a[i]*b[i];na+=a[i]*a[i];nb+=b[i]*b[i];}
  return dp / (Math.sqrt(na)*Math.sqrt(nb) + 1e-9);
}

export function pickNextPair(
  ids: string[],                      // from hard anchors only
  feats: Record<string, Vec>,         // genre/decade/etc one-hots
  state: BTLState
): [string,string] {
  // 1) pick a high-uncertainty pivot near the current decision boundary (p~0.5)
  const sorted = ids.slice().sort((a,b)=>(state.theta[b]??0)-(state.theta[a]??0));
  const mid = Math.floor(sorted.length/2);
  const window = sorted.slice(Math.max(0, mid-12), mid+12);
  const pivot = window.sort((a,b)=>uncertainty(state,b)-uncertainty(state,a))[0];

  // 2) choose opponent that maximizes [uncertainty] × [feature distance] × [score proximity]
  let best = '', bestScore = -1;
  for (const j of ids) if (j!==pivot) {
    const u = Math.min(uncertainty(state,pivot), uncertainty(state,j));
    const dist = 1 - cosine(feats[pivot], feats[j]);        // larger => more contrast
    const prox = Math.exp(-Math.abs((state.theta[pivot]??0)-(state.theta[j]??0))); // near boundary
    const s = u * dist * prox;
    if (s > bestScore) { bestScore = s; best = j; }
  }
  return [pivot, best];
}

(This follows the literature: adapt questions to maximize information gain by querying uncertain items against contrasting ones.  ￼ ￼)

4) Post-test re-rank with MMR (relevance vs diversity)

// mmr.ts
export function mmrSelect(
  candidates: string[],
  relevance: (id:string)=>number,    // your cosine/genre blend
  sim: (a:string,b:string)=>number,  // cosine in embedding space
  k=5, lambda=0.75
){
  const selected: string[] = [];
  const pool = new Set(candidates);
  while (selected.length < k && pool.size) {
    let best = '', bestVal = -Infinity;
    for (const id of pool) {
      const rel = relevance(id);
      const div = selected.length ? Math.max(...selected.map(s=>sim(id,s))) : 0;
      const val = lambda*rel - (1-lambda)*div;
      if (val > bestVal) { bestVal = val; best = id; }
    }
    selected.push(best); pool.delete(best);
  }
  return selected;
}

(MMR balances “close to my taste” with “not all the same thing.”  ￼ ￼)

5) “Where to watch” (AU)

Keep Flicks as the universal link + pills for AU services (Netflix, Stan, Binge, Prime, Disney+, Apple TV, Google Play, SBS On Demand, ABC iview, Foxtel Now, etc.). Their platform roundup is current and AU-specific, which is handy for QA.  ￼

⸻

Sanity checks to add now
	•	Assert every A/B round draws only from the hardlist.
	•	Log per-round: {pair, p_hat, u_i,u_j, feature_dist} to verify “uncertainty × distance” behavior.
	•	After 12 rounds, print top-8 by theta + chosen MMR 5 with their relevance/diversity terms.

If you want, I can wire these three files (btl.ts, pair_pick.ts, mmr.ts) into your repo structure next so Replit stops surfacing those random deep cuts and sticks to the anchors while still learning real preferences.