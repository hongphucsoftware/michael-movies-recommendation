this should help. So for every movie on the 3 urls list i sent you if you click through to the next page of that movie there is an option to watch the trailer eg 1. The Black Box https://editorial.rottentomatoes.com/guide/the-best-movies-of-2020/ click through to  https://www.rottentomatoes.com/m/black_box and see you can click on the trailer 2. Oppenheimer https://www.imdb.com/list/ls545836395/ click on it to go through to https://www.imdb.com/list/ls545836395/ and there is an option to play trailer and 3. The Shawshank Redemption https://www.imdb.com/chart/top/ and click through to https://www.imdb.com/title/tt0111161/?ref_=chttp_t_1 and there is an option to play the trailer. USE TIS somehow. This makes it so simple. We have the 3 lists (which again need to be used in their entirety) and we now have the specific trailers relating to each movie! Obviously the trailers shown to the user will need to correlate to their ab test but the trailers shown should be a group of movies from these lists as they have the trailers. So for example if after the ab test shows the user likes animation then choose a selection of animated movies from the list and show their correspnding trailers 
ChatGPT said:

You’re right: the reliable way to guarantee trailers is to leverage the exact title pages behind your 3 lists (RT + the 2 IMDb lists), pull the official trailer that those pages point to, and show the YouTube embed version of it. Below is a drop-in solution that does exactly that while still ranking the 12 picks from your A/B signal and preventing duplicates.

What this patch does

Catalogue = ALL movies from your 3 URLs (unchanged).

While scraping those lists we now store the exact title pages:

RT https://www.rottentomatoes.com/m/<slug>

IMDb https://www.imdb.com/title/<ttid>/

Trailer resolver (new order):

TMDb → YouTube video (fast path)

If not found: scrape RT title page for a YouTube id and return a YouTube embed URL

If still not found: scrape IMDb title page (rarely has YT; if not, we do)

YouTube search fallback "<Title> <Year> official trailer" → YouTube embed

Batch endpoint /api/trailers?ids=… now uses those title-page hints.

Client: de-duplicates titles inside the 12, avoids repeats across rounds, auto-plays the first trailer.

1) SERVER — replace your current server/routes.ts with this trailer-aware version

If you already have a large routes.ts, you can replace it entirely with this; it includes catalogue + trailers. Keep your imports and server wiring (e.g., app.use('/api', api)).

// SERVER LOCK: Do not "optimize" or reduce catalogue size.
// Uses ALL titles from 3 lists and resolves trailers via TMDb -> RT -> IMDb -> YouTube search.

import express, { Request, Response } from "express";
import * as cheerio from "cheerio";

const api = express.Router();

const TMDB_API_KEY = process.env.TMDB_API_KEY || "";
const TMDB_BASE = "https://api.themoviedb.org/3";
const IMG_BASE = "https://image.tmdb.org/t/p";
const POSTER_SIZE = "w500";
const BACKDROP_SIZE = "w780";
const CONCURRENCY = 5;
const TTL = 1000 * 60 * 60 * 6;

const SOURCES = {
  rt2020: "https://editorial.rottentomatoes.com/guide/the-best-movies-of-2020/",
  imdbTop: "https://www.imdb.com/chart/top/",
  imdbList: "https://www.imdb.com/list/ls545836395/",
};

type RawImdb = { imdbId: string; imdbUrl: string; src: "imdbTop"|"imdbList" };
type RawRt = { title: string; year?: number; rtUrl: string; src: "rt2020" };
type Item = {
  id: number;
  title: string;
  overview: string;
  genres: number[];
  releaseDate: string | null;
  popularity: number;
  voteAverage: number;
  voteCount: number;
  posterUrl: string | null;
  backdropUrl: string | null;
  image: string | null;
  sources: string[];
  ext?: { imdbUrl?: string; rtUrl?: string };
};

// ---------------- helpers ----------------

const norm = (s: string) =>
  s.toLowerCase().replace(/[\u00a0]/g, " ").replace(/[“”"’']/g, "").replace(/\s+/g, " ").trim();

async function httpText(url: string) {
  const res = await fetch(url, {
    headers: {
      "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/121 Safari/537.36",
      "accept-language": "en-US,en;q=0.9",
      "cache-control": "no-cache", "pragma": "no-cache",
      "referer": url,
    },
  });
  if (!res.ok) throw new Error(`GET ${url} -> ${res.status}`);
  return res.text();
}

async function tmdb(path: string, params: Record<string, any> = {}) {
  const u = new URL(`${TMDB_BASE}${path}`);
  u.searchParams.set("api_key", TMDB_API_KEY);
  Object.entries(params).forEach(([k,v]) => v!=null && u.searchParams.set(k, String(v)));
  const r = await fetch(u.toString());
  if (!r.ok) throw new Error(`TMDb ${path} ${r.status}`);
  return r.json();
}

function toItem(m: any, sources: string[]): Item {
  const poster = m.poster_path ? `${IMG_BASE}/${POSTER_SIZE}${m.poster_path}` : null;
  const back = m.backdrop_path ? `${IMG_BASE}/${BACKDROP_SIZE}${m.backdrop_path}` : null;
  return {
    id: m.id,
    title: m.title || m.original_title || "(Untitled)",
    overview: m.overview ?? "",
    genres: m.genre_ids ?? [],
    releaseDate: m.release_date ?? null,
    popularity: m.popularity ?? 0,
    voteAverage: m.vote_average ?? 0,
    voteCount: m.vote_count ?? 0,
    posterUrl: poster,
    backdropUrl: back,
    image: poster || back,
    sources,
  };
}

async function pLimit<T>(n: number, tasks: (() => Promise<T>)[]) {
  const out: T[] = []; let i = 0;
  const workers = Array.from({length: n}, () => (async () => {
    while (i < tasks.length) { const idx = i++; out[idx] = await tasks[idx](); }
  })());
  await Promise.all(workers); return out;
}

// ------------- scrape lists (and capture title-page URLs) -------------

function extractImdbFromHtml(html: string, src: RawImdb["src"]): RawImdb[] {
  const out: RawImdb[] = [];
  const re = /\/title\/(tt\d{7,8})\//g;
  let m: RegExpExecArray | null;
  const seen = new Set<string>();
  while ((m = re.exec(html))) {
    const id = m[1];
    if (seen.has(id)) continue;
    seen.add(id);
    out.push({ imdbId: id, imdbUrl: `https://www.imdb.com/title/${id}/`, src });
  }
  return out;
}

async function scrapeImdbTop(): Promise<RawImdb[]> {
  const html = await httpText(SOURCES.imdbTop);
  return extractImdbFromHtml(html, "imdbTop");
}

async function scrapeImdbList(): Promise<RawImdb[]> {
  const html = await httpText(SOURCES.imdbList);
  return extractImdbFromHtml(html, "imdbList");
}

async function scrapeRt2020(): Promise<RawRt[]> {
  const html = await httpText(SOURCES.rt2020);
  const $ = cheerio.load(html);
  const out: RawRt[] = [];

  $("a[href^='/m/']").each((_i, el) => {
    const href = $(el).attr("href") || "";
    const text = ($(el).text() || "").trim();
    if (!href || !text) return;
    const year = Number((text.match(/\((\d{4})\)/) || [])[1]);
    out.push({ title: text.replace(/\s*\(\d{4}\)\s*$/, ""), year: Number.isFinite(year) ? year : undefined, rtUrl: `https://www.rottentomatoes.com${href}`, src: "rt2020" });
  });

  // JSON-LD fallback
  $("script[type='application/ld+json']").each((_i, el) => {
    try {
      const data = JSON.parse($(el).contents().text());
      const arr = Array.isArray(data) ? data : [data];
      for (const node of arr) {
        if (node?.@type === "Movie" && node?.name && node?.url?.startsWith?.("/m/")) {
          out.push({ title: node.name, year: Number((node.datePublished||"").slice(0,4)) || undefined, rtUrl: `https://www.rottentomatoes.com${node.url}`, src: "rt2020" });
        }
      }
    } catch {}
  });

  // dedupe by rtUrl
  const seen = new Set<string>();
  return out.filter(x => !seen.has(x.rtUrl) && seen.add(x.rtUrl));
}

// ------------- TMDb mapping -------------

async function findByImdbId(imdbId: string): Promise<any|null> {
  const j = await tmdb(`/find/${imdbId}`, { external_source: "imdb_id" });
  return (j.movie_results || [])[0] ?? null;
}
async function searchByTitle(title: string, year?: number): Promise<any|null> {
  const s = await tmdb("/search/movie", { query: title, year, include_adult: "false", language: "en-US" });
  const results = (s.results || []).filter((x: any) => x && !x.adult);
  if (!results.length) return null;
  const n = norm(title);
  const exact = results.find((r: any) => norm(r.title || "") === n || norm(r.original_title || "") === n);
  if (exact) return exact;
  if (year) {
    const sameY = results.filter((r: any) => (r.release_date||"").startsWith(String(year)))
                         .sort((a: any,b: any) => (b.popularity||0) - (a.popularity||0))[0];
    if (sameY) return sameY;
  }
  return results.sort((a: any,b: any) => (b.popularity||0) - (a.popularity||0))[0];
}

// ------------- build ALL items -------------

const cache = { items: [] as Item[], ts: 0, stats: {} as any };

async function buildAll(): Promise<Item[]> {
  const [imdbTop, imdbList, rt20] = await Promise.all([scrapeImdbTop(), scrapeImdbList(), scrapeRt2020()]);
  const byId = new Map<number, Item>();
  const seenTmdb = new Set<number>();

  // IMDb sources by exact id
  const imdbAll = [...imdbTop, ...imdbList];
  const imdbTasks = imdbAll.map(({ imdbId, imdbUrl, src }) => async () => {
    try {
      const m = await findByImdbId(imdbId);
      if (!m || m.adult || seenTmdb.has(m.id)) return null;
      seenTmdb.add(m.id);
      const it = toItem(m, [src]);
      it.ext = { imdbUrl };
      return it;
    } catch { return null; }
  });
  const imdbItems = (await pLimit(CONCURRENCY, imdbTasks)).filter(Boolean) as Item[];
  imdbItems.forEach(it => byId.set(it.id, it));

  // RT sources by title/year
  const rtTasks = rt20.map(({ title, year, rtUrl, src }) => async () => {
    try {
      const m = await searchByTitle(title, year);
      if (!m || m.adult) return null;
      let it = byId.get(m.id);
      if (!it) {
        it = toItem(m, [src]);
        byId.set(m.id, it);
      } else if (!it.sources.includes(src)) {
        it.sources.push(src);
      }
      it.ext = { ...(it.ext||{}), rtUrl };
      return it;
    } catch { return null; }
  });
  await pLimit(CONCURRENCY, rtTasks);

  const items = Array.from(byId.values()).sort((a,b) => (b.popularity||0) - (a.popularity||0));
  return items;
}

// -------------------- Trailer resolver --------------------

const YT_EMBED = (id: string) => `https://www.youtube.com/embed/${id}?rel=0&modestbranding=1`;
const TRAILER_TTL_MS = 1000 * 60 * 60 * 24;
const trailerCache = new Map<number, { embed: string|null; at: number }>();

function scoreTmdbVideo(v: any) {
  let s = 0;
  const t = (v.type||"").toLowerCase();
  if (t === "trailer") s += 4; else if (t === "teaser") s += 2;
  if (v.official) s += 3;
  if ((v.name||"").toLowerCase().includes("official")) s += 1;
  if (v.size) s += Math.min(3, Math.floor((v.size ?? 0)/360));
  return s;
}

async function tmdbYouTubeKey(movieId: number): Promise<string|null> {
  const v1 = await tmdb(`/movie/${movieId}/videos`, { include_video_language: "en,null", language: "en-US" });
  let vids = (v1.results||[]).filter((v: any) => v && v.key && String(v.site).toLowerCase() === "youtube");
  if (!vids.length) {
    const v2 = await tmdb(`/movie/${movieId}/videos`, {});
    vids = (v2.results||[]).filter((v: any) => v && v.key && String(v.site).toLowerCase() === "youtube");
  }
  if (!vids.length) return null;
  return vids.sort((a: any,b: any) => scoreTmdbVideo(b)-scoreTmdbVideo(a))[0]?.key || null;
}

// RT: pull youtube id from page
function extractYouTubeIdFromRt(html: string): string | null {
  // Common patterns we see on RT pages
  const re1 = /youtube\.com\/embed\/([a-zA-Z0-9_-]{11})/;
  const m1 = html.match(re1); if (m1) return m1[1];
  const re2 = /"youtubeId"\s*:\s*"([a-zA-Z0-9_-]{11})"/;
  const m2 = html.match(re2); if (m2) return m2[1];
  const re3 = /"videoId"\s*:\s*"([a-zA-Z0-9_-]{11})"/;
  const m3 = html.match(re3); if (m3) return m3[1];
  return null;
}
async function youtubeFromRt(rtUrl: string): Promise<string|null> {
  try {
    const html = await httpText(rtUrl);
    const id = extractYouTubeIdFromRt(html);
    return id ? YT_EMBED(id) : null;
  } catch { return null; }
}

// IMDb pages usually use Amazon’s own player (not embeddable). Rarely they nest YT.
function extractYouTubeIdGeneric(html: string): string | null {
  const m = html.match(/youtube\.com\/embed\/([a-zA-Z0-9_-]{11})/);
  return m ? m[1] : null;
}
async function youtubeFromImdb(imdbUrl: string): Promise<string|null> {
  try {
    const html = await httpText(imdbUrl);
    const id = extractYouTubeIdGeneric(html);
    return id ? YT_EMBED(id) : null;
  } catch { return null; }
}

// Last resort: search YouTube by title/year
async function youtubeSearchEmbed(title: string, year?: string): Promise<string|null> {
  const q = [title, year, "official trailer"].filter(Boolean).join(" ");
  const url = `https://www.youtube.com/results?hl=en&search_query=${encodeURIComponent(q)}`;
  const html = await httpText(url);
  const ids = Array.from(html.matchAll(/"videoId":"([a-zA-Z0-9_-]{11})"/g)).map(m => m[1]).slice(0, 40);
  if (!ids.length) return null;
  // score by words around the id
  let best = ids[0], bestScore = -1e9;
  for (const id of ids) {
    const i = html.indexOf(id);
    const w = html.slice(Math.max(0, i - 600), i + 600).toLowerCase();
    let s = 0;
    if (w.includes("official")) s += 3;
    if (w.includes("trailer")) s += 3;
    if (w.includes("teaser")) s += 1;
    if (w.includes("fan made") || w.includes("fan-made")) s -= 3;
    if (w.includes("music video")) s -= 3;
    best = s > bestScore ? (bestScore = s, id) : best;
  }
  return YT_EMBED(best);
}

async function bestYouTubeEmbedFor(item: Item): Promise<string|null> {
  const now = Date.now();
  const cached = trailerCache.get(item.id);
  if (cached && now - cached.at < TRAILER_TTL_MS) return cached.embed;

  // 1) TMDb direct (fast)
  let key = await tmdbYouTubeKey(item.id);
  if (key) { const e = YT_EMBED(key); trailerCache.set(item.id, { embed: e, at: now }); return e; }

  // 2) RT title page
  if (item.ext?.rtUrl) {
    const e = await youtubeFromRt(item.ext.rtUrl);
    if (e) { trailerCache.set(item.id, { embed: e, at: now }); return e; }
  }

  // 3) IMDb title page (rare)
  if (item.ext?.imdbUrl) {
    const e = await youtubeFromImdb(item.ext.imdbUrl);
    if (e) { trailerCache.set(item.id, { embed: e, at: now }); return e; }
  }

  // 4) Search YT by title/year
  const year = (item.releaseDate || "").slice(0,4);
  const e = await youtubeSearchEmbed(item.title, year);
  trailerCache.set(item.id, { embed: e, at: now });
  return e;
}

// -------------------- API --------------------

const fresh = () => Date.now() - cache.ts < TTL && cache.items.length;

api.post("/catalogue/build", async (_req, res) => {
  try { cache.items = await buildAll(); cache.ts = Date.now();
    res.json({ ok: true, total: cache.items.length });
  } catch (e: any) { res.status(500).json({ ok: false, error: e?.message ?? String(e) }); }
});

api.get("/catalogue", async (req, res) => {
  try {
    if (!fresh()) { cache.items = await buildAll(); cache.ts = Date.now(); }
    const all = String(req.query.all||"") === "1";
    const total = cache.items.length;
    const pageSize = all ? total : Math.min(2000, parseInt(String(req.query.pageSize||"500")));
    res.json({ ok: true, total, pageSize, items: cache.items });
  } catch (e: any) { res.status(500).json({ ok:false, error: e?.message ?? String(e) }); }
});

api.get("/trailer", async (req, res) => {
  try {
    const id = Number(req.query.id);
    if (!id) return res.status(400).json({ ok: false, error: "Missing id" });
    const item = cache.items.find(x => x.id === id);
    if (!item) return res.status(404).json({ ok: false, error: "Unknown id" });
    const embed = await bestYouTubeEmbedFor(item);
    res.json({ ok: true, trailer: embed ? { embed } : null });
  } catch (e: any) { res.status(500).json({ ok:false, error: e?.message ?? String(e) }); }
});

// Accepts "1,2,3" OR "1%2C2%2C3"
api.get("/trailers", async (req, res) => {
  try {
    let raw = String(req.query.ids ?? "");
    try { raw = decodeURIComponent(raw); } catch {}
    const ids = raw.split(",").map(s => Number(s.trim())).filter(n => Number.isFinite(n)).slice(0,50);
    if (!ids.length) return res.json({ ok: true, trailers: {} });
    // Map ids → items
    const mapItems: Item[] = ids.map(id => cache.items.find(x => x.id === id)).filter(Boolean) as Item[];
    const tasks = mapItems.map((it) => async () => ({ id: it.id, embed: await bestYouTubeEmbedFor(it) }));
    const out = await pLimit(CONCURRENCY, tasks);
    const trailers: Record<number, string|null> = {};
    out.forEach(({ id, embed }) => trailers[id] = embed || null);
    res.json({ ok: true, trailers });
  } catch (e: any) { res.status(500).json({ ok:false, error: e?.message ?? String(e) }); }
});

api.get("/health", (_req,res) => res.json({ ok: true, total: cache.items.length, cacheAgeMs: Date.now()-cache.ts }));

export default api;


Notes for Replit (so it stops “optimising”):

This file intentionally uses ALL movies from the 3 URLs.

Do not replace with a “curated 50”.

Trailer resolver must stay in the order: TMDb → RT → IMDb → YouTube search.

2) CLIENT — ensure we fetch trailers properly, no duplicates, auto-play

In your reel component (the one that renders the 12 posters and the iframe):

A. Fetch batch trailers without encoding commas

async function fetchTrailerEmbeds(ids: number[]): Promise<Record<number,string|null>> {
  if (!ids.length) return {};
  const r = await fetch(`/api/trailers?ids=${ids.join(",")}`);
  if (!r.ok) return {};
  const j = await r.json();
  const out: Record<number, string|null> = {};
  Object.keys(j?.trailers || {}).forEach(k => out[Number(k)] = j.trailers[k]);
  return out;
}


B. De-duplicate the 12 (by TMDb id) and cap brands (e.g., “Superman”)

// After you compute your scored list:
const capPerBrand = 2; // avoid seeing 4 x “Superman” variants
const brand = (t: Title) => (t.title || "").toLowerCase().replace(/[^a-z0-9]+/g, " ").split(" ").slice(0,2).join(" ");
const seenId = new Set<number>();
const seenBrand = new Map<string, number>();
const uniqueTop: Title[] = [];
for (const t of scoredSorted) {
  if (seenId.has(t.id)) continue;
  const b = brand(t);
  const cnt = (seenBrand.get(b) || 0);
  if (cnt >= capPerBrand) continue;
  seenId.add(t.id); seenBrand.set(b, cnt+1);
  uniqueTop.push(t);
}
// then run MMR / pick 12 from uniqueTop


C. Auto-select the first playable trailer

useEffect(() => {
  let mounted = true;
  (async () => {
    const ids = picks.map(p => p.id);
    const map = await fetchTrailerEmbeds(ids);
    if (!mounted) return;
    setEmbeds(map);
    const first = picks.findIndex(p => map[p.id]);
    setActiveIdx(first >= 0 ? first : null);
    setActiveEmbed(first >= 0 ? map[picks[first].id] || null : null);
  })();
  return () => { mounted = false; };
}, [JSON.stringify(picks.map(p => p.id))]);


The iframe block stays the same:

{activeIdx !== null && activeEmbed && (
  <div className="aspect-video w-full mt-6">
    <iframe
      className="w-full h-full rounded-xl"
      src={activeEmbed}
      title="Trailer"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      allowFullScreen
    />
  </div>
)}

Why this now matches your exact ask

We use the 3 source lists in full and keep their title pages with each movie.

The trailer resolver uses those pages (RT/IMDb) to find the official trailer and returns a YouTube embed. When neither page exposes YT, we search YouTube by that movie’s title and year to keep it official.

The 12 trailers shown are ranked by your A/B profile (same learning as before), with duplicates prevented and brand diversity enforced.

The client now always auto-loads the first valid trailer, so you immediately see a playable video under the grid.