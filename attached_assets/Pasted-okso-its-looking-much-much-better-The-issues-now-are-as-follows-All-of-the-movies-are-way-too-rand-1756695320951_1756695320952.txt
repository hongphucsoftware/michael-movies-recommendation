okso its looking much much better. The issues now are as follows. All of the movies are way too random (there is asian porn in there!) but the posters and layout is great. it looks like it is connecting to TMDB perfectly through an API. Now that we have the database set correctly, can we look up the movies/posters from that database that correlate to these lists only (for now) https://editorial.rottentomatoes.com/guide/the-best-movies-of-2020/ and https://www.imdb.com/list/ls545836395/ and https://www.imdb.com/chart/top/ Finally - the youtube/trailer section seems to not be working. Can we get that back up and runniong. Again, by looking up the titles that correlate to the lists from the urls. so its all about the names/titles of the movies. Kind of like a lookup table in excel (dont do that but you get what i mean). If you understand write the code for replit so this will happen
ChatGPT said:
Thought for 1m 4s

Totally get it. We’ll switch to a curated catalogue that only includes movies from the three links you gave (RT 2020 list + IMDb Top 250 + that specific IMDb list), and fix trailers so they resolve reliably.

Below is a drop-in replacement for server/routes.ts that:

Scrapes those three pages to collect titles (+ years when available)

Looks each title up on TMDb (adult disabled), prefers exact/year matches, then popularity

Builds a clean, deduped catalogue (poster-first images) — no random/NSFW noise

Improves trailer picking (second-chance fetch + “Teaser” fallback if no “Trailer”)

Keeps the same endpoints you already wired:

GET /api/catalogue → now serves curated results

POST /api/catalogue/build → force rebuild curated cache

GET /api/trailer?id=TMDB_ID → best YouTube/Vimeo trailer

One-time install (server)

In Replit shell (or “Packages” tab):

npm i cheerio


(We use cheerio to parse the HTML from RT/IMDb.)

server/routes.ts (replace entire file)
import express, { Request, Response } from "express";
import * as cheerio from "cheerio";

// ---------- Config ----------
const TMDB_API_KEY = process.env.TMDB_API_KEY || process.env.TMDB_KEY || "";
if (!TMDB_API_KEY) {
  console.warn("[TMDB] Missing TMDB_API_KEY (or TMDB_KEY). Set it in Replit Secrets.");
}

const TMDB_BASE = "https://api.themoviedb.org/3";
const IMG_BASE = "https://image.tmdb.org/t/p";
const POSTER_SIZE = "w500";
const BACKDROP_SIZE = "w780";
const CATALOGUE_TTL_MS = 1000 * 60 * 60 * 6; // 6 hours

// Curated sources (your three links)
const CURATED_SOURCES = {
  rt2020: "https://editorial.rottentomatoes.com/guide/the-best-movies-of-2020/",
  imdbTop: "https://www.imdb.com/chart/top/",
  imdbList: "https://www.imdb.com/list/ls545836395/",
};

type TMDbMovie = {
  id: number;
  title?: string;
  original_title?: string;
  overview?: string;
  genre_ids?: number[];
  release_date?: string;
  poster_path?: string | null;
  backdrop_path?: string | null;
  popularity?: number;
  vote_average?: number;
  vote_count?: number;
  adult?: boolean;
};

type CatalogueItem = {
  id: number; // TMDb ID
  title: string;
  overview: string;
  genres: number[];
  releaseDate: string | null;
  popularity: number;
  voteAverage: number;
  voteCount: number;
  posterUrl: string | null;
  backdropUrl: string | null;
};

type TrailerInfo = {
  site: "YouTube" | "Vimeo" | "Unknown";
  key: string;
  url: string;
  name: string;
  size?: number;
  official?: boolean;
  type?: string;
};

const api = express.Router();

// ---------- In-memory cache ----------
const cache = {
  catalogue: [] as CatalogueItem[],
  ts: 0,
};

function isCatalogueFresh() {
  return Date.now() - cache.ts < CATALOGUE_TTL_MS && cache.catalogue.length > 0;
}

// ---------- Helpers ----------
async function httpText(url: string): Promise<string> {
  const res = await fetch(url, {
    headers: {
      "user-agent":
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119 Safari/537.36",
      accept: "text/html,application/xhtml+xml",
    },
  });
  if (!res.ok) {
    const t = await res.text();
    throw new Error(`Fetch ${url} failed ${res.status}: ${t.slice(0, 200)}`);
  }
  return res.text();
}

async function tmdb(path: string, params: Record<string, any> = {}) {
  const url = new URL(`${TMDB_BASE}${path}`);
  url.searchParams.set("api_key", TMDB_API_KEY);
  for (const [k, v] of Object.entries(params)) {
    if (v !== undefined && v !== null) url.searchParams.set(k, String(v));
  }
  const res = await fetch(url.toString());
  if (!res.ok) {
    const text = await res.text();
    throw new Error(`TMDb ${path} failed ${res.status}: ${text}`);
  }
  return res.json();
}

function toItem(m: TMDbMovie): CatalogueItem {
  const title = m.title || m.original_title || "(Untitled)";
  const posterUrl = m.poster_path ? `${IMG_BASE}/${POSTER_SIZE}${m.poster_path}` : null;
  const backdropUrl = m.backdrop_path ? `${IMG_BASE}/${BACKDROP_SIZE}${m.backdrop_path}` : null;
  return {
    id: m.id,
    title,
    overview: m.overview ?? "",
    genres: m.genre_ids ?? [],
    releaseDate: m.release_date ?? null,
    popularity: m.popularity ?? 0,
    voteAverage: m.vote_average ?? 0,
    voteCount: m.vote_count ?? 0,
    posterUrl,
    backdropUrl,
  };
}

// ---------- Scrapers (robust, minimal assumptions) ----------
type RawTitle = { title: string; year?: number };

// Rotten Tomatoes editorial list pages
async function scrapeRTTitles(url: string): Promise<RawTitle[]> {
  const html = await httpText(url);
  const $ = cheerio.load(html);

  const out: RawTitle[] = [];
  // Grab obvious movie links: /m/<slug> (canonical on RT)
  $("a[href^='/m/']").each((_i, el) => {
    const t = $(el).text().trim();
    if (t && t.length > 1) out.push({ title: cleanTitle(t) });
  });

  // Also look for headings like "Movie Name (2020)"
  $("h2,h3,h4").each((_i, el) => {
    const txt = $(el).text().trim();
    const m = txt.match(/^(.*)\s+\((\d{4})\)$/);
    if (m) out.push({ title: cleanTitle(m[1]), year: Number(m[2]) });
  });

  return dedupeRaw(out);
}

// IMDb Top 250 (single page)
async function scrapeImdbTop(url: string): Promise<RawTitle[]> {
  const html = await httpText(url);
  const $ = cheerio.load(html);
  const out: RawTitle[] = [];

  $("td.titleColumn").each((_i, el) => {
    const a = $(el).find("a").first();
    const title = cleanTitle(a.text().trim());
    const yearTxt = $(el).find("span.secondaryInfo").first().text().trim(); // "(1972)"
    const year = parseYear(yearTxt);
    if (title) out.push({ title, year: year ?? undefined });
  });

  return dedupeRaw(out);
}

// Generic IMDb list (supports pagination via ?page=)
async function scrapeImdbList(url: string, maxPages = 10): Promise<RawTitle[]> {
  const out: RawTitle[] = [];

  for (let page = 1; page <= maxPages; page++) {
    const pageUrl = url.endsWith("/") ? `${url}?page=${page}` : `${url}/?page=${page}`;
    const html = await httpText(pageUrl);
    const $ = cheerio.load(html);

    let found = 0;
    $("h3.lister-item-header").each((_i, el) => {
      const a = $(el).find("a").first();
      const title = cleanTitle(a.text().trim());
      const yearTxt = $(el).find(".lister-item-year").first().text().trim();
      const year = parseYear(yearTxt);
      if (title) {
        out.push({ title, year: year ?? undefined });
        found++;
      }
    });

    // If the structure is the new grid layout, fall back to generic anchors
    if (found === 0) {
      $("a[href^='/title/']").each((_i, el) => {
        const t = cleanTitle($(el).text().trim());
        if (t) {
          out.push({ title: t });
          found++;
        }
      });
    }

    // Stop if nothing meaningful found (no more pages)
    if (found === 0) break;
  }

  return dedupeRaw(out);
}

function cleanTitle(t: string) {
  // strip ranking numbers like "1. The Godfather"
  return t.replace(/^\d+\.\s*/, "").replace(/\u00A0/g, " ").trim();
}
function parseYear(s: string): number | null {
  const m = s.match(/(\d{4})/);
  return m ? Number(m[1]) : null;
}
function dedupeRaw(arr: RawTitle[]): RawTitle[] {
  const seen = new Set<string>();
  const out: RawTitle[] = [];
  for (const r of arr) {
    const key = `${r.title.toLowerCase()}|${r.year ?? ""}`;
    if (!seen.has(key)) {
      seen.add(key);
      out.push(r);
    }
  }
  return out;
}

// ---------- Curated catalogue builder ----------
async function curatedCatalogue(): Promise<CatalogueItem[]> {
  if (!TMDB_API_KEY) return [];

  // 1) Scrape the three lists
  const [rt2020, imdbTop, imdbList] = await Promise.all([
    scrapeRTTitles(CURATED_SOURCES.rt2020),
    scrapeImdbTop(CURATED_SOURCES.imdbTop),
    scrapeImdbList(CURATED_SOURCES.imdbList),
  ]);

  // Merge & dedupe by (title,year?)
  const rawSet = dedupeRaw([...rt2020, ...imdbTop, ...imdbList]);

  // 2) Resolve each to a TMDb movie (adult disabled). Keep it polite on rate limits.
  const items: CatalogueItem[] = [];
  const seen = new Set<number>();

  for (const r of rawSet) {
    const m = await searchOneOnTmdb(r.title, r.year);
    if (!m) continue;
    if (m.adult) continue; // hard no
    if (seen.has(m.id)) continue;
    seen.add(m.id);
    items.push(toItem(m));

    // tiny delay to be kind to TMDb
    await sleep(60);
  }

  // Sort: prefer having posters, then popularity
  items.sort((a, b) => {
    const ap = a.posterUrl ? 1 : 0;
    const bp = b.posterUrl ? 1 : 0;
    if (bp !== ap) return bp - ap;
    return (b.popularity ?? 0) - (a.popularity ?? 0);
  });

  return items;
}

async function searchOneOnTmdb(title: string, year?: number): Promise<TMDbMovie | null> {
  // Primary search with year if available
  const params: any = {
    query: title,
    include_adult: "false",
    language: "en-US",
  };
  if (year) params.year = year;

  const s1 = await tmdb("/search/movie", params);
  const candidates: TMDbMovie[] = (s1.results || []).filter((x) => x && !x.adult);

  const exact = candidates.find(
    (c) =>
      c.title?.toLowerCase() === title.toLowerCase() ||
      c.original_title?.toLowerCase() === title.toLowerCase()
  );
  if (exact) return exact;

  if (year) {
    const byYear = candidates.find((c) => (c.release_date || "").startsWith(String(year)));
    if (byYear) return byYear;
  }

  // fallback: most popular
  const best = candidates.sort((a, b) => (b.popularity ?? 0) - (a.popularity ?? 0))[0];
  return best ?? null;
}

function sleep(ms: number) {
  return new Promise((r) => setTimeout(r, ms));
}

// ---------- Routes ----------

// Paged catalogue (now **curated** by default)
api.get("/catalogue", async (req: Request, res: Response) => {
  try {
    if (!isCatalogueFresh()) {
      cache.catalogue = await curatedCatalogue();
      cache.ts = Date.now();
    }

    const page = Math.max(1, parseInt(String(req.query.page ?? "1"), 10));
    const pageSize = Math.min(100, Math.max(1, parseInt(String(req.query.pageSize ?? "60"), 10)));
    const start = (page - 1) * pageSize;
    const slice = cache.catalogue.slice(start, start + pageSize);

    const normalized = slice.map((m) => ({
      ...m,
      image: m.posterUrl || m.backdropUrl || null,
    }));

    res.json({
      ok: true,
      total: cache.catalogue.length,
      page,
      pageSize,
      items: normalized,
      learnedDims: 12,
      cacheAgeMs: Date.now() - cache.ts,
      source: "curated(rt2020 + imdbTop250 + imdb list)",
    });
  } catch (err: any) {
    res.status(500).json({ ok: false, error: err.message ?? String(err) });
  }
});

// Force rebuild (still curated)
api.post("/catalogue/build", async (_req: Request, res: Response) => {
  try {
    cache.catalogue = await curatedCatalogue();
    cache.ts = Date.now();
    res.json({ ok: true, total: cache.catalogue.length, rebuiltAt: cache.ts });
  } catch (err: any) {
    res.status(500).json({ ok: false, error: err.message ?? String(err) });
  }
});

// Flush cache
api.post("/cache/flush", (_req: Request, res: Response) => {
  cache.catalogue = [];
  cache.ts = 0;
  res.json({ ok: true });
});

// Trailer for a movie (improved fallback)
api.get("/trailer", async (req: Request, res: Response) => {
  try {
    const id = Number(req.query.id);
    if (!id) return res.status(400).json({ ok: false, error: "Missing id" });
    if (!TMDB_API_KEY) return res.status(400).json({ ok: false, error: "TMDB_API_KEY not set" });

    // 1) Try with inclusive languages (en + null)
    let vids = await fetchVideos(id, { include_video_language: "en,null", language: "en-US" });

    // 2) Fallback: no language filter
    if (!vids.length) vids = await fetchVideos(id, {});

    const best = scoreVideos(vids)[0];
    if (!best) return res.json({ ok: true, trailer: null });

    const t: TrailerInfo = {
      site: (best.site as any) || "Unknown",
      key: best.key,
      url:
        (best.site || "").toLowerCase() === "youtube"
          ? `https://www.youtube.com/watch?v=${best.key}`
          : (best.site || "").toLowerCase() === "vimeo"
          ? `https://vimeo.com/${best.key}`
          : best.key,
      name: best.name,
      size: best.size,
      official: best.official,
      type: best.type,
    };

    res.json({ ok: true, trailer: t });
  } catch (err: any) {
    res.status(500).json({ ok: false, error: err.message ?? String(err) });
  }
});

async function fetchVideos(id: number, extra: Record<string, any>) {
  const json = await tmdb(`/movie/${id}/videos`, extra);
  return (json?.results || []).filter((v: any) => v && v.key);
}

function scoreVideos(vids: any[]) {
  return vids
    .map((v) => {
      let score = 0;
      const type = (v.type || "").toLowerCase();
      if (type === "trailer") score += 4;
      else if (type === "teaser") score += 2;

      if (v.official) score += 3;
      if ((v.site || "").toLowerCase() === "youtube") score += 2;
      if ((v.name || "").toLowerCase().includes("official")) score += 1;
      if (v.size) score += Math.min(3, Math.floor((v.size ?? 0) / 360)); // 720/1080 bump

      return { ...v, __score: score };
    })
    .sort((a, b) => b.__score - a.__score);
}

// Health
api.get("/health", (_req, res) => {
  res.json({
    ok: true,
    cacheItems: cache.catalogue.length,
    cacheAgeMs: Date.now() - cache.ts,
  });
});

export default api;

/**
 * server/index.ts example:
 * ------------------------
 * import express from "express";
 * import api from "./routes";
 * const app = express();
 * app.use(express.json());
 * app.use("/api", api);
 * app.listen(process.env.PORT || 3000, () => console.log("Server started"));
 */

What changes for you

Install cheerio (once):

npm i cheerio


Rebuild the curated cache:

POST /api/catalogue/build


(or just refresh the app — the first GET /api/catalogue will auto-build).

Test trailers
Open a title; when your UI calls GET /api/trailer?id=..., it should now return a YouTube/Vimeo URL most of the time. If a movie genuinely has no trailer on TMDb, we return trailer: null (you can show “Try another title”).