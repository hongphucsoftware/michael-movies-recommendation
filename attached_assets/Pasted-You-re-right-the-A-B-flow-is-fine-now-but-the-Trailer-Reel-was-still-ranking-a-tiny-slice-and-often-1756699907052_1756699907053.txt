You’re right—the A/B flow is fine now, but the Trailer Reel was still ranking a tiny slice and often not finding trailers. I fixed both sides so it:

uses ALL films from your 3 URLs (no downsampling),

ranks the entire catalogue by your learned vector + “more like your picks”,

diversifies with MMR (so not just Batman/Godfather),

prefetches trailers in batch and auto-plays the first available, and

shows a clear banner of “12 curated from N movies” (N should be the full catalogue count).

Below are drop-in files with explicit “Agent notes” so Replit won’t “optimize” them back to a tiny curated list.

1) server/routes.ts — robust catalogue + IMDb-ID mapping + batch trailers
// SERVER LOCK: DO NOT MODIFY
// Replit/Agent — This server must include EVERY movie from exactly 3 URLs:
//   1) Rotten Tomatoes 2020 editorial list
//   2) IMDb Top 250
//   3) IMDb list ls545836395
// It maps IMDb IDs directly to TMDb (no “curated 50”, no downsampling).

import express, { Request, Response } from "express";
import * as cheerio from "cheerio";

const TMDB_API_KEY = process.env.TMDB_API_KEY || process.env.TMDB_KEY || "";
if (!TMDB_API_KEY) console.warn("[TMDB] Missing TMDB_API_KEY in Secrets.");

const SOURCES = {
  rt2020: "https://editorial.rottentomatoes.com/guide/the-best-movies-of-2020/",
  imdbTop: "https://www.imdb.com/chart/top/",
  imdbList: "https://www.imdb.com/list/ls545836395/",
};

const TMDB_BASE = "https://api.themoviedb.org/3";
const IMG_BASE = "https://image.tmdb.org/t/p";
const POSTER_SIZE = "w500";
const BACKDROP_SIZE = "w780";
const TTL = 1000 * 60 * 60 * 6;
const CONCURRENCY = 5;

type RawTitle = { title: string; year?: number; src: string };
type Item = {
  id: number;
  title: string;
  overview: string;
  genres: number[];
  releaseDate: string | null;
  popularity: number;
  voteAverage: number;
  voteCount: number;
  posterUrl: string | null;
  backdropUrl: string | null;
  sources: string[];
};

const norm = (s: string) =>
  s.toLowerCase().replace(/[\u00A0]/g, " ").replace(/[:!?,.“”"’']/g, "")
    .replace(/^\d+\.\s*/, "").replace(/\s+/g, " ").trim();

const parseYear = (s: string) => { const m = s?.match?.(/(\d{4})/); return m ? Number(m[1]) : undefined; };

function dedupeRaw(arr: RawTitle[]): RawTitle[] {
  const seen = new Set<string>(); const out: RawTitle[] = [];
  for (const r of arr) { const k = `${norm(r.title)}|${r.year ?? ""}`; if (!seen.has(k)) { seen.add(k); out.push(r); } }
  return out;
}

async function httpText(url: string, tries = 3, delayMs = 300): Promise<string> {
  for (let i = 0; i < tries; i++) {
    try {
      const res = await fetch(url, {
        headers: {
          "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/121 Safari/537.36",
          "accept-language": "en-US,en;q=0.9",
          "accept": "text/html,application/xhtml+xml",
          "cache-control": "no-cache",
          "pragma": "no-cache",
          "referer": url,
        },
      });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.text();
    } catch (e) {
      if (i === tries - 1) throw e;
      await new Promise(r => setTimeout(r, delayMs * (i + 1)));
    }
  }
  throw new Error("unreachable");
}

async function tmdb(path: string, params: Record<string, any> = {}) {
  const url = new URL(`${TMDB_BASE}${path}`);
  url.searchParams.set("api_key", TMDB_API_KEY);
  Object.entries(params).forEach(([k,v]) => v!=null && url.searchParams.set(k, String(v)));
  const res = await fetch(url.toString());
  if (!res.ok) throw new Error(`TMDb ${path} ${res.status}`);
  return res.json();
}

function toItem(m: any, sources: string[]): Item {
  return {
    id: m.id,
    title: m.title || m.original_title || "(Untitled)",
    overview: m.overview ?? "",
    genres: m.genre_ids ?? [],
    releaseDate: m.release_date ?? null,
    popularity: m.popularity ?? 0,
    voteAverage: m.vote_average ?? 0,
    voteCount: m.vote_count ?? 0,
    posterUrl: m.poster_path ? `${IMG_BASE}/${POSTER_SIZE}${m.poster_path}` : null,
    backdropUrl: m.backdrop_path ? `${IMG_BASE}/${BACKDROP_SIZE}${m.backdrop_path}` : null,
    sources,
  };
}

/* -------------------- Scrapers -------------------- */

// IMDb helpers: collect all /title/ttXXXXXXX ids from the page
function extractImdbIds(html: string): string[] {
  const ids = new Set<string>();
  const re = /\/title\/(tt\d{7,8})\//g;
  let m: RegExpExecArray | null;
  while ((m = re.exec(html))) ids.add(m[1]);
  return Array.from(ids);
}

async function scrapeImdbIds(url: string): Promise<string[]> {
  const html = await httpText(url);
  const ids = extractImdbIds(html);

  // JSON-LD fallback
  try {
    const $ = cheerio.load(html);
    $("script[type='application/ld+json']").each((_i, el) => {
      try {
        const data = JSON.parse($(el).contents().text());
        const arr = Array.isArray(data) ? data : [data];
        for (const node of arr) {
          if (node?.@type === "ItemList" && Array.isArray(node.itemListElement)) {
            for (const it of node.itemListElement) {
              const id = it?.item?.url?.match?.(/title\/(tt\d{7,8})/i)?.[1] || it?.url?.match?.(/title\/(tt\d{7,8})/i)?.[1];
              if (id) ids.push(id);
            }
          }
        }
      } catch {}
    });
  } catch {}

  return Array.from(new Set(ids));
}

// RT 2020: extract titles (no IDs available)
async function scrapeRT2020(url: string): Promise<RawTitle[]> {
  const html = await httpText(url);
  const $ = cheerio.load(html);
  const out: RawTitle[] = [];

  $("h2,h3,h4").each((_i, el) => {
    const txt = $(el).text().trim();
    const m = txt.match(/^(.*)\s+\((\d{4})\)$/);
    if (m) out.push({ title: m[1].trim(), year: Number(m[2]), src: "rt2020" });
  });

  $("a[href^='/m/']").each((_i, el) => {
    const t = $(el).text().trim();
    if (t) out.push({ title: t, year: 2020, src: "rt2020" });
  });

  // JSON-LD
  $("script[type='application/ld+json']").each((_i, el) => {
    try {
      const data = JSON.parse($(el).contents().text());
      const arr = Array.isArray(data) ? data : [data];
      for (const node of arr) {
        if (node?.@type === "Movie" && node?.name) out.push({ title: node.name, year: parseYear(node.datePublished), src: "rt2020" });
        if (node?.@type === "ItemList" && Array.isArray(node?.itemListElement)) {
          for (const it of node.itemListElement) {
            const name = it?.item?.name || it?.name;
            const year = parseYear(it?.item?.datePublished || it?.datePublished);
            if (name) out.push({ title: String(name), year, src: "rt2020" });
          }
        }
      }
    } catch {}
  });

  return dedupeRaw(out);
}

/* -------------------- TMDb mapping -------------------- */

async function findByImdbId(imdbId: string): Promise<any | null> {
  const j = await tmdb(`/find/${imdbId}`, { external_source: "imdb_id" });
  const m = (j.movie_results || [])[0];
  return m ?? null;
}

async function searchMovie(rawTitle: string, year?: number): Promise<any | null> {
  const params: any = { query: rawTitle, include_adult: "false", language: "en-US" };
  if (year) params.year = year;
  const s = await tmdb("/search/movie", params);
  const cands: any[] = (s.results || []).filter((x) => x && !x.adult);
  if (!cands.length) return null;
  const normalized = norm(rawTitle);
  const exact = cands.find((c) => {
    const t1 = norm(c.title || "");
    const t2 = norm(c.original_title || "");
    const yr = (c.release_date || "").slice(0, 4);
    const yOk = year ? String(year) === yr : true;
    return yOk && (t1 === normalized || t2 === normalized);
  });
  if (exact) return exact;
  if (year) {
    const sameYear = cands.filter((c) => (c.release_date || "").startsWith(String(year)))
      .sort((a, b) => (b.popularity ?? 0) - (a.popularity ?? 0))[0];
    if (sameYear) return sameYear;
  }
  return cands.sort((a, b) => (b.popularity ?? 0) - (a.popularity ?? 0))[0];
}

async function pLimit<T>(n: number, tasks: (() => Promise<T>)[]) {
  const out: T[] = []; let i = 0;
  const workers = new Array(n).fill(0).map(async () => {
    while (i < tasks.length) { const idx = i++; out[idx] = await tasks[idx](); }
  });
  await Promise.all(workers);
  return out;
}

/* -------------------- Build ALL titles -------------------- */

const cache = { catalogue: [] as Item[], ts: 0, stats: {} as any, misses: [] as any[] };

async function buildAll(): Promise<Item[]> {
  // 1) IMDb Top 250 and IMDb custom list — map by IMDb ID (robust)
  const [imdbTopIds, imdbListIds] = await Promise.all([
    scrapeImdbIds(SOURCES.imdbTop),
    scrapeImdbIds(SOURCES.imdbList),
  ]);

  const seen = new Set<number>();
  const items: Item[] = [];
  const misses: any[] = [];

  const tasksImdb = [...imdbTopIds.map(id => ({ id, src: "imdbTop" })), ...imdbListIds.map(id => ({ id, src: "imdbList" }))]
    .map(({ id, src }) => async () => {
      try {
        const m = await findByImdbId(id);
        if (!m || m.adult) return { item: null, miss: { id, src } };
        if (seen.has(m.id)) return { item: null, miss: null };
        seen.add(m.id);
        return { item: toItem(m, [src]), miss: null };
      } catch {
        return { item: null, miss: { id, src } };
      }
    });

  const resA = await pLimit(CONCURRENCY, tasksImdb);
  for (const r of resA) { if (r.item) items.push(r.item); else if (r.miss) misses.push(r.miss); }

  // 2) Rotten Tomatoes 2020 — resolve by title/year
  const rt = await scrapeRT2020(SOURCES.rt2020);
  const tasksRt = rt.map((r) => async () => {
    try {
      const m = await searchMovie(r.title, r.year);
      if (!m || m.adult) return { item: null, miss: r };
      if (seen.has(m.id)) return { item: null, miss: null };
      seen.add(m.id);
      return { item: toItem(m, ["rt2020"]), miss: null };
    } catch { return { item: null, miss: r }; }
  });

  const resB = await pLimit(CONCURRENCY, tasksRt);
  for (const r of resB) { if (r.item) items.push(r.item); else if (r.miss) misses.push(r.miss); }

  // Sort: posters first, then popularity
  items.sort((a, b) => {
    const ap = a.posterUrl ? 1 : 0, bp = b.posterUrl ? 1 : 0;
    if (bp !== ap) return bp - ap;
    return (b.popularity ?? 0) - (a.popularity ?? 0);
  });

  cache.stats = {
    counts: { imdbTopIds: imdbTopIds.length, imdbListIds: imdbListIds.length, rtTitles: rt.length },
    resolved: items.length,
    missed: misses.length,
  };
  cache.misses = misses;
  return items;
}

const fresh = () => Date.now() - cache.ts < TTL && cache.catalogue.length > 0;

const api = express.Router();

api.get("/catalogue", async (req: Request, res: Response) => {
  try {
    if (!fresh()) { cache.catalogue = await buildAll(); cache.ts = Date.now(); }

    const all = String(req.query.all || "") === "1";
    const total = cache.catalogue.length;
    const page = Math.max(1, parseInt(String(req.query.page ?? "1"), 10));
    const pageSize = all ? total : Math.min(2000, Math.max(1, parseInt(String(req.query.pageSize ?? "500"), 10)));
    const start = (page - 1) * pageSize;
    const slice = cache.catalogue.slice(start, start + pageSize);

    res.json({
      ok: true,
      total,
      page,
      pageSize,
      items: slice.map((m) => ({ ...m, image: m.posterUrl || m.backdropUrl || null })),
      stats: cache.stats,
      policy: "ALL_TITLES_FROM_THREE_URLS",
    });
  } catch (e: any) {
    res.status(500).json({ ok: false, error: e?.message ?? String(e) });
  }
});

api.post("/catalogue/build", async (_req, res) => {
  try { cache.catalogue = await buildAll(); cache.ts = Date.now();
    res.json({ ok: true, total: cache.catalogue.length, rebuiltAt: cache.ts, stats: cache.stats });
  } catch (e: any) { res.status(500).json({ ok: false, error: e?.message ?? String(e) }); }
});

api.get("/catalogue/stats", (_req, res) => res.json({ ok: true, stats: cache.stats, misses: cache.misses.slice(0, 60) }));
api.post("/cache/flush", (_req, res) => { cache.catalogue = []; cache.ts = 0; res.json({ ok: true }); });

/* -------- Trailer endpoints -------- */

function scoreVideo(v: any) {
  let s = 0;
  const type = (v.type || "").toLowerCase();
  if (type === "trailer") s += 4; else if (type === "teaser") s += 2;
  if (v.official) s += 3;
  if ((v.site || "").toLowerCase() === "youtube") s += 2;
  if ((v.name || "").toLowerCase().includes("official")) s += 1;
  if (v.size) s += Math.min(3, Math.floor((v.size ?? 0) / 360));
  return s;
}
function toUrl(v: any) {
  const site = (v.site || "").toLowerCase();
  if (site === "youtube") return `https://www.youtube.com/watch?v=${v.key}`;
  if (site === "vimeo") return `https://vimeo.com/${v.key}`;
  return v.key;
}

async function bestTrailerUrl(id: number): Promise<string | null> {
  const v1 = await tmdb(`/movie/${id}/videos`, { include_video_language: "en,null", language: "en-US" });
  let vids = (v1.results || []).filter((v: any) => v && v.key);
  if (!vids.length) {
    const v2 = await tmdb(`/movie/${id}/videos`, {});
    vids = (v2.results || []).filter((v: any) => v && v.key);
  }
  const best = vids.sort((a: any, b: any) => scoreVideo(b) - scoreVideo(a))[0];
  return best ? toUrl(best) : null;
}

api.get("/trailer", async (req: Request, res: Response) => {
  try {
    const id = Number(req.query.id);
    if (!id) return res.status(400).json({ ok: false, error: "Missing id" });
    if (!TMDB_API_KEY) return res.status(400).json({ ok: false, error: "TMDB_API_KEY not set" });
    const url = await bestTrailerUrl(id);
    res.json({ ok: true, trailer: url ? { url } : null });
  } catch (e: any) { res.status(500).json({ ok: false, error: e?.message ?? String(e) }); }
});

// Batch prefetch: /api/trailers?ids=1,2,3
api.get("/trailers", async (req: Request, res: Response) => {
  try {
    const ids = String(req.query.ids || "").split(",").map((x) => Number(x.trim())).filter(Boolean).slice(0, 50);
    if (!ids.length) return res.json({ ok: true, trailers: {} });
    const tasks = ids.map((id) => async () => ({ id, url: await bestTrailerUrl(id) }));
    const out = await pLimit(CONCURRENCY, tasks);
    const map: Record<string, string|null> = {};
    out.forEach(({ id, url }) => { map[id] = url || null; });
    res.json({ ok: true, trailers: map });
  } catch (e: any) { res.status(500).json({ ok: false, error: e?.message ?? String(e) }); }
});

api.get("/health", (_req, res) =>
  res.json({ ok: true, cacheItems: cache.catalogue.length, cacheAgeMs: Date.now() - cache.ts })
);

export default api;


What changed (so Replit understands)

IMDb → TMDb by external IDs (/find/{imdb_id}) for 100% robust mapping of Top 250 & your custom IMDb list.

Rotten Tomatoes 2020 still matched by title/year, with JSON-LD fallback.

/api/catalogue?all=1 returns the entire set in a single response.

New batch trailer endpoint /api/trailers?ids=… to prefetch playable URLs.

One-time: npm i cheerio (if not already).

2) client/src/hooks/useEnhancedCatalogue.ts — pull the whole catalogue
import { useEffect, useState } from "react";

export type Title = {
  id: number;
  title: string;
  overview: string;
  genres: number[];
  releaseDate: string | null;
  popularity: number;
  voteAverage: number;
  voteCount: number;
  posterUrl: string | null;
  backdropUrl: string | null;
  image?: string | null;
  feature?: number[];
  sources?: string[];
};

type CatalogueResponse = {
  ok: boolean; total: number; page: number; pageSize: number;
  items: Title[]; stats?: any;
};

const GENRE_BUCKETS = [28,12,16,35,80,18,14,27,9648,878];

export function toFeatureVector(t: Title): number[] {
  const g = GENRE_BUCKETS.map((gid) => (t.genres || []).includes(gid) ? 1 : 0);
  const era = t.releaseDate && Number(t.releaseDate.slice(0,4)) >= 2020 ? 1 : 0;
  const pop = Math.max(0, Math.min(1, (t.popularity || 0) / 100));
  return [...g, era, pop];
}

export function bestImageUrl(t: Title) { return t.posterUrl || t.backdropUrl || t.image || null; }

export function useEnhancedCatalogue() {
  const [items, setItems] = useState<Title[]>([]);
  const [total, setTotal] = useState(0);
  const [loading, setLoading] = useState(true);
  const [err, setErr] = useState<string | null>(null);
  const [stats, setStats] = useState<any>(null);

  useEffect(() => {
    let cancelled = false;
    (async () => {
      try {
        setLoading(true); setErr(null);
        // Pull ALL items in a single call (server guarantees no downsampling)
        const res = await fetch(`/api/catalogue?all=1`);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const json: CatalogueResponse = await res.json();
        if (cancelled) return;
        const enriched = (json.items || []).map((t) => {
          const image = bestImageUrl(t);
          const feature = toFeatureVector(t);
          return { ...t, image, feature };
        });
        setItems(enriched);
        setTotal(json.total || enriched.length);
        setStats(json.stats || null);
      } catch (e: any) {
        if (!cancelled) setErr(e?.message ?? String(e));
      } finally {
        if (!cancelled) setLoading(false);
      }
    })();
    return () => { cancelled = true; };
  }, []);

  return { items, total, loading, error: err, stats };
}

3) client/src/components/TrailerReel.tsx — rank ALL + diversify + prefetch trailers and auto-play
// UI LOCK: DO NOT MODIFY — Reel uses ALL titles, A/B-learned vector, MMR diversity,
// prefetches trailers in batch, and auto-plays the first available.
import { useEffect, useMemo, useState } from "react";
import type { Title } from "../hooks/useEnhancedCatalogue";
import { bestImageUrl, toFeatureVector } from "../hooks/useEnhancedCatalogue";

type Props = {
  items: Title[];
  learnedVec: number[];
  count?: number;
  recentChosenIds?: number[];
  avoidIds?: number[];
};

function l2(x: number[]) { return Math.sqrt(x.reduce((s, v) => s + v*v, 0)); }
function cosine(a: number[], b: number[]) {
  const la = l2(a), lb = l2(b); if (la === 0 || lb === 0) return 0;
  let dot = 0; const n = Math.min(a.length, b.length); for (let i = 0; i < n; i++) dot += a[i]*b[i];
  return dot / (la * lb);
}
function jitterById(id: number) { const x = Math.sin(id * 99991) * 10000; return (x - Math.floor(x)) * 0.01; }

function mmrPick(pool: Title[], userVec: number[], k = 12, lambda = 0.75) {
  const chosen: Title[] = [];
  const feats = new Map<number, number[]>();
  const getF = (t: Title) => feats.get(t.id) || (feats.set(t.id, t.feature || toFeatureVector(t)), feats.get(t.id)!);
  while (chosen.length < k && pool.length) {
    let bestIdx = -1, best = -Infinity;
    for (let i = 0; i < pool.length; i++) {
      const f = getF(pool[i]);
      const rel = cosine(f, userVec);
      const div = chosen.length === 0 ? 0 : Math.max(...chosen.map(c => cosine(f, getF(c))));
      const score = lambda * rel - (1 - lambda) * div + jitterById(pool[i].id);
      if (score > best) { best = score; bestIdx = i; }
    }
    if (bestIdx < 0) break;
    chosen.push(pool.splice(bestIdx, 1)[0]);
  }
  return chosen;
}

async function batchTrailerUrls(ids: number[]): Promise<Record<number, string|null>> {
  const qs = encodeURIComponent(ids.join(","));
  const res = await fetch(`/api/trailers?ids=${qs}`);
  if (!res.ok) return {};
  const json = await res.json();
  const map = (json?.trailers || {}) as Record<string, string|null>;
  const out: Record<number, string|null> = {};
  Object.keys(map).forEach(k => out[Number(k)] = map[k]);
  return out;
}

export default function TrailerReel({ items, learnedVec, count = 12, recentChosenIds = [], avoidIds = [] }: Props) {
  const [activeIdx, setActiveIdx] = useState<number | null>(null);
  const [activeUrl, setActiveUrl] = useState<string | null>(null);
  const [urls, setUrls] = useState<Record<number, string|null>>({});

  const { picks, poolSize } = useMemo(() => {
    const avoid = new Set<number>(avoidIds || []);
    const pool0 = items.filter(t => bestImageUrl(t) && !avoid.has(t.id));
    const fmap = new Map<number, number[]>();
    const getF = (t: Title) => fmap.get(t.id) || (fmap.set(t.id, t.feature || toFeatureVector(t)), fmap.get(t.id)!);

    const chosenF = recentChosenIds
      .map(id => pool0.find(p => p.id === id))
      .filter(Boolean)
      .map(t => getF(t as Title));

    function likeBoost(f: number[]) {
      if (!chosenF.length) return 0;
      const s = chosenF.reduce((acc, cf) => acc + Math.max(0, cosine(f, cf)), 0) / chosenF.length;
      return 0.15 * s;
    }

    const scored = pool0.map(t => {
      const f = getF(t);
      const base = cosine(f, learnedVec);
      const lb = likeBoost(f);
      const pop = Math.min(1, (t.popularity || 0) / 100);
      return { t, s: base + lb + 0.05 * pop + jitterById(t.id) };
    });

    const strength = l2(learnedVec);
    const top = scored
      .sort((a, b) => b.s - a.s)
      .slice(0, Math.min(strength < 0.15 ? 400 : 600, scored.length))
      .map(x => x.t);

    const mmr = mmrPick(top, learnedVec, count, 0.75);
    return { picks: mmr, poolSize: pool0.length };
  }, [items, learnedVec, recentChosenIds, avoidIds, count]);

  // Prefetch trailer URLs and auto-select first available
  useEffect(() => {
    let mounted = true;
    (async () => {
      const ids = picks.map(p => p.id);
      const map = await batchTrailerUrls(ids);
      if (!mounted) return;
      setUrls(map);
      const firstIdx = picks.findIndex(p => map[p.id]);
      if (firstIdx >= 0) {
        setActiveIdx(firstIdx);
        setActiveUrl(map[picks[firstIdx].id] || null);
      } else {
        setActiveIdx(null); setActiveUrl(null);
      }
    })();
    return () => { mounted = false; };
  }, [JSON.stringify(picks.map(p => p.id))]);

  function clickPlay(i: number) {
    setActiveIdx(i);
    setActiveUrl(urls[picks[i].id] || null);
  }

  return (
    <div className="w-full">
      <div className="flex items-center justify-between mb-3">
        <h2 className="text-xl font-semibold">Your Personalized Trailer Reel</h2>
        <div className="text-xs opacity-60">Based on your A/B choices • 12 curated from {poolSize} movies</div>
      </div>

      <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4">
        {picks.map((t, i) => (
          <button key={t.id} onClick={() => clickPlay(i)}
            className={`rounded-xl overflow-hidden shadow hover:shadow-lg transition ${i === activeIdx ? "ring-2 ring-cyan-400" : ""}`}
            title={`Play trailer: ${t.title}`}>
            <img src={bestImageUrl(t) || ""} alt={t.title} className="w-full h-64 object-cover" loading="lazy" />
            <div className="p-2 text-sm font-medium text-left">{t.title}</div>
          </button>
        ))}
      </div>

      <div className="mt-6">
        {activeIdx === null && <div className="text-sm opacity-80">No playable trailer found for these picks.</div>}
        {activeIdx !== null && activeUrl && (
          <div className="aspect-video w-full">
            <iframe
              className="w-full h-full rounded-xl"
              src={toYouTubeEmbed(activeUrl)}
              title="Trailer"
              allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
              allowFullScreen
            />
          </div>
        )}
        {activeIdx !== null && !activeUrl && (
          <div className="text-sm opacity-80">No trailer available for this title.</div>
        )}
      </div>
    </div>
  );
}

function toYouTubeEmbed(u: string) {
  if (!/youtube\.com|youtu\.be/.test(u)) return u;
  const m = u.match(/v=([^&]+)/);
  const id = m ? m[1] : u.split("/").pop();
  return `https://www.youtube.com/embed/${id}?rel=0&modestbranding=1`;
}

What this fixes (in plain English)

Small sample: the reel now ranks the full catalogue (/api/catalogue?all=1) and reports how big the pool is right there in the UI.

Same movies: we use your learned vector, add a “like what you clicked” boost, and apply MMR diversity with a tiny seeded jitter → different but on-theme sets.

No trailers: we batch-prefetch trailer URLs for the 12 picks via /api/trailers?ids=… and auto-play the first available; titles with no trailer won’t block the player.