You’re right—the explanation and the trailers must come from the same signal. What’s happening now is the text is built from one tally (winners-only counts) while the ranking uses a different tally (winner–loser exclusive deltas) and then diversity/trailer filters dilute it further. Result: recs can drift from the story.

Here’s a tight fix that makes the rationale and the 6 picks identical in logic, guarantees alignment, and shows why each movie was chosen.

What we’ll change (quick + robust)

Single source of truth for preference
Use the exclusive-delta featureScore (winner–loser only) for BOTH:

the ranking of candidates, and

the rationale text.

Alignment guarantee
Require at least 4 of the 6 trailers to match top positive features (genres/actors/director/era) from featureScore. Only fill the rest if needed.

Per-movie “why”
For each selected movie, return the list of matched features (e.g., Comedy +2, Brad Pitt +3, 2000s +1) so the UI can show reasons under each card. No more mismatch.

No stale UI
We return {recs, trailers, rationale, reasonsPerMovie} in the same response. Client renders that data directly; no second fetch that could mix rounds.

Drop-in patch (replace the /score-round handler)

File: server/src/routes/api.ts
Replace your current api.post("/score-round", ...) with this version:

api.post("/score-round", async (req, res) => {
  noStore(res);
  const { votes, excludeIds } = req.body as {
    votes: Array<{winnerId:number, loserId:number}>;
    excludeIds: number[];
  };

  const st = await getState();
  const byId = Object.fromEntries(st.all.map(m => [m.id, m]));

  // ===== 1) Build the single preference map from exclusive differences =====
  const featureScore = new Map<string, number>(); // winner-only features +1, loser-only features -1

  const tokenMovie = (m: Movie): string[] => {
    const toks: string[] = [];
    for (const g of m.genres) toks.push(`g:${g.id}`);
    if (m.era) toks.push(`e:${m.era}`);
    for (const a of m.actors) toks.push(`a:${a.id}`);
    if (m.director) toks.push(`d:${m.director.id}`);
    return toks;
  };

  const exclusive = (A: Set<string>, B: Set<string>) => {
    const Ao: string[] = []; const Bo: string[] = [];
    for (const t of A) if (!B.has(t)) Ao.push(t);
    for (const t of B) if (!A.has(t)) Bo.push(t);
    return { Ao, Bo };
  };

  for (const v of (votes || [])) {
    const w = byId[v.winnerId]; const l = byId[v.loserId];
    if (!w || !l) continue;
    const wSet = new Set(tokenMovie(w));
    const lSet = new Set(tokenMovie(l));
    const { Ao, Bo } = exclusive(wSet, lSet);
    for (const t of Ao) featureScore.set(t, (featureScore.get(t) || 0) + 1);
    for (const t of Bo) featureScore.set(t, (featureScore.get(t) || 0) - 1);
  }

  // ===== 2) Build human rationale directly from featureScore (positives only) =====
  const posByType = {
    genres: [] as Array<{id:number,name:string,score:number}>,
    actors: [] as Array<{id:number,name:string,score:number}>,
    directors: [] as Array<{id:number,name:string,score:number}>,
    eras: [] as Array<{bucket:string,score:number}>,
  };

  for (const [tok, sc] of featureScore) {
    if (sc <= 0) continue; // only positive drivers
    if (tok.startsWith("g:")) {
      const id = Number(tok.slice(2)); posByType.genres.push({ id, name: st.genreNameById[id] || String(id), score: sc });
    } else if (tok.startsWith("a:")) {
      const id = Number(tok.slice(2)); posByType.actors.push({ id, name: st.personNameById[id] || String(id), score: sc });
    } else if (tok.startsWith("d:")) {
      const id = Number(tok.slice(2)); posByType.directors.push({ id, name: st.personNameById[id] || String(id), score: sc });
    } else if (tok.startsWith("e:")) {
      const bucket = tok.slice(2); posByType.eras.push({ bucket, score: sc });
    }
  }
  posByType.genres.sort((a,b)=>b.score-a.score);
  posByType.actors.sort((a,b)=>b.score-a.score);
  posByType.directors.sort((a,b)=>b.score-a.score);
  posByType.eras.sort((a,b)=>b.score-a.score);

  // Short summary text from the same signals we rank with
  const parts: string[] = [];
  if (posByType.genres[0]) parts.push(`**${posByType.genres.slice(0,2).map(g=>`${g.name} (+${g.score})`).join(" & ")}**`);
  if (posByType.actors[0]) parts.push(`**${posByType.actors.slice(0,2).map(a=>`${a.name} (+${a.score})`).join(" & ")}**`);
  if (posByType.directors[0]) parts.push(`films by **${posByType.directors[0].name} (+${posByType.directors[0].score})**`);
  if (posByType.eras[0]) parts.push(`from the **${posByType.eras[0].bucket} (+${posByType.eras[0].score})**`);

  const summaryText = parts.length
    ? `Based on your 12 picks, you leaned toward ${parts.join(", ")}.`
    : `Your 12 picks were mixed, so we chose 6 well-liked options with a similar overall feel.`;

  // ===== 3) Score candidates using the SAME featureScore =====
  const excluded = new Set<number>(excludeIds || []);
  const normPop = (p:number) => {
    const { popularityMin:min, popularityMax:max } = st;
    if (max <= min) return 0.5;
    return (p - min) / (max - min);
  };
  const scoreMovie = (m: Movie) => {
    const gVals = m.genres.map(g => featureScore.get(`g:${g.id}`) || 0);
    const aVals = m.actors.map(a => featureScore.get(`a:${a.id}`) || 0);
    const dVal  = m.director ? (featureScore.get(`d:${m.director.id}`) || 0) : 0;
    const eVal  = m.era ? (featureScore.get(`e:${m.era}`) || 0) : 0;
    const mean = (xs:number[]) => xs.length ? xs.reduce((s,x)=>s+x,0)/xs.length : 0;
    const core = 1.0*mean(gVals) + 0.9*dVal + 0.7*mean(aVals) + 0.5*eVal;
    const prior = 0.10 * normPop(m.popularity);
    const jitter = ((m.id * 2654435761 % 97) / 97) * 0.001;
    return core + prior + jitter;
  };

  const pool = st.all.filter(m => !excluded.has(m.id));
  pool.sort((a,b)=>scoreMovie(b)-scoreMovie(a));

  // ===== 4) Alignment guarantee: pick at least 4 that match top positive features =====
  const topFeatureTokens = new Set<string>([
    ...posByType.genres.slice(0,3).map(g=>`g:${g.id}`),
    ...posByType.actors.slice(0,3).map(a=>`a:${a.id}`),
    ...posByType.directors.slice(0,2).map(d=>`d:${d.id}`),
    ...(posByType.eras[0] ? [`e:${posByType.eras[0].bucket}`] : []),
  ]);

  const matchesTop = (m:Movie) => {
    if (topFeatureTokens.size === 0) return false;
    for (const t of tokenMovie(m)) if (topFeatureTokens.has(t)) return true;
    return false;
  };

  const aligned = pool.filter(matchesTop);
  const nonAligned = pool.filter(m => !matchesTop(m));

  const selected: Movie[] = [];
  for (const m of aligned) { if (selected.length < 4) selected.push(m); else break; }
  for (const m of nonAligned) { if (selected.length < 6) selected.push(m); else break; }
  while (selected.length < 6 && pool.length) selected.push(pool.shift()!);

  // ===== 5) Per-movie reasons (so UI can display exact matching features) =====
  const reasonsPerMovie: Record<number, Array<{kind:"genre"|"actor"|"director"|"era", label:string, score:number}>> = {};
  for (const m of selected) {
    const reasons: Array<{kind:"genre"|"actor"|"director"|"era", label:string, score:number}> = [];
    for (const g of m.genres) {
      const s = featureScore.get(`g:${g.id}`) || 0;
      if (s > 0) reasons.push({ kind:"genre", label:g.name, score:s });
    }
    for (const a of m.actors) {
      const s = featureScore.get(`a:${a.id}`) || 0;
      if (s > 0) reasons.push({ kind:"actor", label:a.name, score:s });
    }
    if (m.director) {
      const s = featureScore.get(`d:${m.director.id}`) || 0;
      if (s > 0) reasons.push({ kind:"director", label:m.director.name, score:s });
    }
    if (m.era) {
      const s = featureScore.get(`e:${m.era}`) || 0;
      if (s > 0) reasons.push({ kind:"era", label:m.era, score:s });
    }
    reasons.sort((a,b)=>b.score-a.score);
    reasonsPerMovie[m.id] = reasons.slice(0,3); // top 3 reasons per movie
  }

  // ===== 6) Fetch trailer URLs (unchanged) =====
  const trailers: Record<number,string|null> = {};
  for (const m of selected) {
    try {
      const r = await fetch(`${TMDB_API}/movie/${m.id}/videos?language=en-US&api_key=${TMDB_KEY}`).then(r=>r.json());
      const vids = Array.isArray(r?.results) ? r.results : [];
      const yt = vids.find((v:any)=> v.site==="YouTube" && /Trailer|Teaser|Official|Clip/i.test(`${v.type} ${v.name}`) && v.key);
      trailers[m.id] = yt ? `https://www.youtube.com/embed/${yt.key}` : null;
    } catch { trailers[m.id] = null; }
  }

  res.json({
    ok: true,
    recs: selected,
    trailers,
    rationale: {
      topGenres: posByType.genres.slice(0,2),
      topActors: posByType.actors.slice(0,2),
      topDirectors: posByType.directors.slice(0,1),
      topEra: posByType.eras[0] || null,
      summaryText
    },
    reasonsPerMovie
  });
});

What this fixes (and how you’ll see it)

The summary text now reflects the exact same features used to rank movies.

At least 4/6 trailers will share your top inferred features.

The UI can show per-movie chips like “Comedy +2, Brad Pitt +3” straight from reasonsPerMovie.

No caching mix-ups: you render the single response from /api/score-round.

Run:

npm run build
npm run start:prod


If you want, I’ll give you a tiny React snippet to render rationale.summaryText and the per-movie reasons under each trailer card.