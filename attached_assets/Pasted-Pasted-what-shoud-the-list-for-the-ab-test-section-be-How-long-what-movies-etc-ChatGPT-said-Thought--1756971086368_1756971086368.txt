Pasted-what-shoud-the-list-for-the-ab-test-section-be-How-long-what-movies-etc-ChatGPT-said-Thought-fo-1756967211955_1756967211955.txt
what shoud the list for the ab test section be? How long? what movies, etc?
ChatGPT said:
Thought for 55s

Totally get what you want: a small, famous “anchor” set for the 12-round A/B only, while the final 5 trailers still come from the full catalogue.

Here’s a clear recipe + a small seed list you can drop in today.

How long?

12 rounds is ideal. (If you ever need faster social traffic, make a 10-round variant.)

R1–4: broad, cross-genre pairs (recognisable hits)

R5–8: drill into the user’s top 2 genres (old vs new, different pace)

R9–12: fine-tune inside the best cluster (aligned vs boundary)

How big is the A/B “anchor” pool?

~120–160 titles total (≈15–25 per cluster) — all well-known.

Must have: working YouTube trailer, brand diversity, decade spread (’70s–’20s).

Keep A/B anchors English-first to reduce cognitive load (final reco can be broader).

What movies? (seed list – 5 per cluster to start)

Use these as an initial seed. Your code can auto-expand to ~20 per cluster using popularity/votes + IMDb Top 250.

Action/Adventure/Thriller
Die Hard · Mad Max: Fury Road · Mission: Impossible – Fallout · John Wick · Skyfall

Comedy/Romance
When Harry Met Sally · Groundhog Day · The Big Sick · Bridesmaids · Crazy Rich Asians

Drama
The Shawshank Redemption · The Social Network · Parasite · Whiplash · Forrest Gump

Horror/Thriller
The Shining · Get Out · A Quiet Place · Hereditary · The Exorcist

Animation/Family
Toy Story · The Lion King · Spirited Away · Up · Spider-Man: Into the Spider-Verse

Sci-Fi/Fantasy
Star Wars: A New Hope · The Matrix · Interstellar · Blade Runner 2049 · The Lord of the Rings: Fellowship

Crime/Mystery
The Departed · Se7en · Knives Out · Heat · Zodiac

If any of these aren’t in your union, your dynamic rules (below) will pick equally famous substitutes.

Replit-ready: build the anchor pool from your catalogue (no hand-curation)

File: client/src/lib/abAnchors.ts

import type { Title } from "../hooks/useEnhancedCatalogue";
import { toFeatureVector } from "../hooks/useEnhancedCatalogue";

const CLUSTERS: Record<string, number[]> = {
  Action: [28,12,53],
  ComedyRomance: [35,10749],
  Drama: [18],
  Horror: [27,53],
  AnimationFamily: [16,10751],
  ScifiFantasy: [878,14],
  CrimeMystery: [80,9648],
};

function clusterOf(t: Title) {
  const gs = t.genres || [];
  let best = "Drama", bestOverlap = -1;
  for (const [name, ids] of Object.entries(CLUSTERS)) {
    const overlap = gs.filter(g => ids.includes(g)).length;
    if (overlap > bestOverlap) { best = name; bestOverlap = overlap; }
  }
  return best;
}

function yearOf(t: Title) {
  const y = (t as any).year || (t as any).release_date || (t as any).releaseDate || "";
  return typeof y === "string" ? Number(y.slice(0,4)) || null : (typeof y === "number" ? y : null);
}

// “Knownness”: IMDb Top 250 gets a boost; popularity & vote_count help.
// Adjust thresholds if needed.
function knownness(t: Title) {
  const src = t.sources || [];
  const imdbTop = src.includes("imdbTop") ? 1.5 : 0;
  const imdbList = src.includes("imdbList") ? 0.5 : 0;
  const pop = Math.min(60, Math.max(0, Number(t.popularity || 0))) / 60; // 0..1
  const votes = Math.min(1, (t.vote_count || 0) / 20000);
  return imdbTop + imdbList + 0.8*pop + 0.5*votes;
}

// Optional: keep A/B anchors English-first (reduces confusion)
function isEnglishish(t: Title) {
  const lang = (t as any).original_language || (t as any).originalLanguage || "en";
  return lang === "en";
}

export type Anchor = Title & { cluster: string; k: number; decade: number };

export function buildABAnchors(full: Title[], maxPerCluster = 22): Anchor[] {
  // 1) prefilter: recognisable + Englishish + has poster
  const pool = full.filter(t => knownness(t) >= 0.6 && isEnglishish(t));

  // 2) rank by “knownness” inside cluster
  const byCluster: Record<string, Anchor[]> = {};
  for (const t of pool) {
    const c = clusterOf(t);
    const y = yearOf(t) || 2000;
    const decade = Math.floor(y/10)*10; // 1970, 1980, …
    const k = knownness(t);
    (byCluster[c] ||= []).push(Object.assign({}, t, { cluster: c, k, decade }));
  }
  for (const c of Object.keys(byCluster)) {
    byCluster[c].sort((a,b) => b.k - a.k);
  }

  // 3) enforce decade spread per cluster (’70s–’20s if available)
  const decades = [1970, 1980, 1990, 2000, 2010, 2020];
  const anchors: Anchor[] = [];
  for (const c of Object.keys(byCluster)) {
    const arr = byCluster[c];
    const taken: Anchor[] = [];

    // pick up to 1 per decade first pass
    for (const d of decades) {
      const hit = arr.find(t => Math.floor((t.decade||2000)/10)*10 === d && !taken.find(x => x.id === t.id));
      if (hit) taken.push(hit);
      if (taken.length >= maxPerCluster) break;
    }
    // top up to quota
    for (const t of arr) {
      if (taken.length >= maxPerCluster) break;
      if (!taken.find(x => x.id === t.id)) taken.push(t);
    }
    anchors.push(...taken.slice(0, maxPerCluster));
  }

  // 4) brand cap: only one per franchise in A...